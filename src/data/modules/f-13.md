# Linux Architecture (High-Level)

## 1. Orientation

### What this module covers
This module provides a comprehensive view of Linux system architecture—from the monolithic kernel design to the userland utilities you'll use daily. Understanding this architecture is essential because Linux underpins most security tools, target servers, cloud infrastructure, and embedded systems you'll encounter.

### Fit in the Learning Path
You will spend 90% of your security career interacting with Linux systems—attacking them, defending them, or using them as platforms. This module moves from abstract OS concepts to the specific architecture of the tool you'll use every day.

### Learning Objectives
By the end of this module, you will:
*   Understand the Linux monolithic kernel architecture
*   Navigate and interpret the virtual filesystems (/proc, /sys)
*   Explain the "everything is a file" philosophy and its implications
*   Identify key Linux components and their security relevance

---

## 2. Core Content

### Mental Model: The Layered System

**How professionals think about this:**
Linux is layers of abstraction, each providing services to the layer above. Security vulnerabilities exist at every layer, and attacks often work by moving between layers or bypassing them entirely.

```
LINUX ARCHITECTURE LAYERS:

┌─────────────────────────────────────────────────────────────────────┐
│                        USER APPLICATIONS                            │
│  bash, python, firefox, nc, nmap, metasploit, etc.                 │
│  Attack surface: Application vulnerabilities, misconfigurations    │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ Uses
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     SHELL / INTERPRETER                             │
│  bash, zsh, sh, python interpreter                                 │
│  Translates commands to system calls                               │
│  Attack surface: Command injection, shell escapes                  │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ Uses
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                 SYSTEM LIBRARIES (libc / glibc)                     │
│  Wrapper functions around system calls                             │
│  malloc(), printf(), socket(), etc.                                │
│  Attack surface: Library vulnerabilities (buffer overflows)        │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ System calls
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                          KERNEL                                     │
│  ┌─────────────┬─────────────┬─────────────┬─────────────────────┐ │
│  │  Process    │  Memory     │   File      │      Device         │ │
│  │ Scheduler   │  Manager    │  Systems    │      Drivers        │ │
│  └─────────────┴─────────────┴─────────────┴─────────────────────┘ │
│  Attack surface: Kernel exploits, driver vulnerabilities          │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ Controls
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         HARDWARE                                    │
│  CPU, RAM, Disk, Network Interface, USB, etc.                      │
│  Attack surface: Firmware, side-channels                           │
└─────────────────────────────────────────────────────────────────────┘
```

### The Monolithic Kernel

**Kernel architecture types:**

| Type | Description | Example |
|------|-------------|---------|
| **Monolithic** | All kernel functions in one binary | Linux, BSD |
| **Microkernel** | Minimal kernel, services in user space | MINIX, QNX |
| **Hybrid** | Combination of approaches | Windows, macOS |

**Linux is monolithic:**
- All drivers, filesystems, networking run in kernel space
- Shared address space = fast communication
- But: Driver bugs can crash entire system

**Loadable Kernel Modules (LKMs):**
Even though monolithic, Linux supports loading modules dynamically:
```bash
# List loaded modules
lsmod

# Module information
modinfo [module_name]

# Load module (as root)
modprobe [module_name]
```

**Security implication:**
Malicious kernel modules (rootkits) can load into this space and become invisible to user-space tools.

### "Everything is a File"

**The Unix philosophy:**
In Linux, most system resources are represented as files. This means file tools work on everything.

```
TRADITIONAL OS:                    LINUX:
┌─────────────────────┐           ┌─────────────────────┐
│ Files → File APIs   │           │ FILES:              │
│ Network → Socket API│           │ Regular files       │
│ Devices → Device API│           │ Devices (/dev/sda)  │
│ Processes → Proc API│           │ Processes (/proc/)  │
└─────────────────────┘           │ Network (sockets)   │
                                  │ System info (/sys)  │
                                  │                     │
                                  │ All accessed with   │
                                  │ read(), write(), etc│
                                  └─────────────────────┘
```

**Security implication:**
- Read the right "file" = read any system information
- Write the right "file" = control any system component
- Permissions on "files" control system access

**Examples:**

| Resource | File Path | Access with |
|----------|-----------|-------------|
| Hard drive | /dev/sda | dd, cat |
| USB keyboard | /dev/input/event0 | cat (see keypresses!) |
| Process memory | /proc/[pid]/mem | Read process memory |
| Network config | /proc/net/tcp | See open connections |
| CPU info | /proc/cpuinfo | cat |
| Kernel parameters | /proc/sys/... | Read/write settings |

### The /proc Virtual Filesystem

**Not stored on disk:**
/proc is a window into kernel data structures. Files are generated on-demand when read.

```
/proc/
├── 1/                    # Process 1 (init/systemd)
│   ├── cmdline           # Command that started the process
│   ├── environ           # Environment variables
│   ├── fd/               # Open file descriptors
│   ├── maps              # Memory mappings
│   └── status            # Process status
├── cpuinfo               # CPU information
├── meminfo               # Memory information
├── net/                  # Network information
│   ├── tcp               # TCP connections
│   └── udp               # UDP connections
├── sys/                  # Tunable kernel parameters
│   ├── kernel/
│   └── net/
└── version               # Kernel version
```

**Security-relevant /proc information:**

| File | Security Use |
|------|--------------|
| /proc/[pid]/cmdline | See what arguments processes were started with |
| /proc/[pid]/environ | Extract environment variables (may contain secrets) |
| /proc/[pid]/maps | Memory layout for exploitation |
| /proc/net/tcp | Currently open connections |
| /proc/modules | Loaded kernel modules |

### The /sys Virtual Filesystem

**Hardware and driver information:**
/sys exposes the device model—hardware, drivers, and their relationships.

```
/sys/
├── block/                # Block devices
│   └── sda/              # SATA drive
├── class/                # Device classes
│   ├── net/              # Network interfaces
│   └── input/            # Input devices
├── devices/              # Device hierarchy
├── firmware/             # Firmware information
└── module/               # Kernel modules
```

### The /dev Directory

**Device files:**
Special files that represent hardware devices.

| Type | Description | Example |
|------|-------------|---------|
| Block | Fixed-size blocks (disks) | /dev/sda, /dev/nvme0n1 |
| Character | Stream of bytes | /dev/tty, /dev/random |
| Pseudo | Virtual devices | /dev/null, /dev/zero |

**Important device files:**

| Device | Purpose | Security Relevance |
|--------|---------|-------------------|
| /dev/null | Discards all input | Hide output |
| /dev/zero | Infinite zeros | Wipe data |
| /dev/random | Random data (blocking) | Cryptographic entropy |
| /dev/urandom | Random data (non-blocking) | Fast random |
| /dev/sda | First SATA disk | Raw disk access |
| /dev/mem | Physical memory | Dangerous if accessible |
| /dev/kmem | Kernel memory | Dangerous if accessible |

**Security note:**
/dev/mem and /dev/kmem allow direct memory access. Modern systems restrict these heavily.

### The Shell

**Not the kernel—an application:**
The shell (bash, zsh, sh) is a user-space program that:
- Reads commands from user
- Parses and interprets them
- Executes programs or built-in commands
- Returns output to user

**Shell types:**

| Shell | Notes |
|-------|-------|
| sh | Original Bourne shell |
| bash | Bourne Again Shell (most common) |
| zsh | Z shell (macOS default, feature-rich) |
| fish | User-friendly, non-POSIX |
| dash | Lightweight, script execution |

**Security note:**
Shell is the most common interactive attack surface. Command injection attacks target the shell.

### Important Linux Directories

```
/
├── bin/                  # Essential user binaries
├── boot/                 # Boot files, kernel
├── dev/                  # Device files
├── etc/                  # Configuration files
│   ├── passwd            # User database
│   ├── shadow            # Password hashes
│   └── ssh/              # SSH configuration
├── home/                 # User home directories
├── lib/                  # Shared libraries
├── opt/                  # Optional/third-party software
├── proc/                 # Process/kernel virtual filesystem
├── root/                 # Root user home
├── run/                  # Runtime data
├── sbin/                 # System binaries
├── sys/                  # Device/driver virtual filesystem
├── tmp/                  # Temporary files (world-writable!)
├── usr/                  # User programs
│   ├── bin/              # User binaries
│   ├── lib/              # Libraries
│   └── share/            # Shared data
└── var/                  # Variable data
    ├── log/              # Log files
    └── www/              # Web server files
```

---

## 3. Guided Practice

### Exercise 1: Exploring /proc

```bash
# System information
cat /proc/cpuinfo | head -20
cat /proc/meminfo | head -10
cat /proc/version

# Process information (pick any PID)
ls -la /proc/1/
cat /proc/1/cmdline

# Network connections
cat /proc/net/tcp | head -5
```

### Exercise 2: Everything is a File

```bash
# Read from a device
head -c 20 /dev/urandom | xxd

# Send to a device
echo "test" > /dev/null

# Check device types
ls -la /dev/sda /dev/null /dev/random
# Note the 'b' (block) and 'c' (character) types
```

### Exercise 3: Kernel Information

```bash
# Kernel version
uname -a

# Loaded modules
lsmod | head -10

# Kernel configuration (if available)
cat /proc/config.gz 2>/dev/null | gunzip | head -20
# Or
cat /boot/config-$(uname -r) | head -20
```

---

## 4. Reflection Check

### Architecture Understanding
1. Why does Linux use a monolithic kernel instead of a microkernel? What's the trade-off?

2. If the shell is "just an application," can you run Linux without a shell?

3. Why is /proc "virtual"? What would be the problem if it were stored on disk?

### Security Implications
1. You have access to /dev/sda (the disk). You're a regular user. What could go wrong?

2. Why is /tmp being world-writable a frequent source of security issues?

3. How could a malicious kernel module hide its presence from lsmod?

---

## 5. Key Misconceptions

**MYTH: "Bash is Linux"**
REALITY: Bash is a user-space application. It can be replaced with any shell, or you could run Linux without a shell entirely.

**MYTH: "/proc files are stored on the disk"**
REALITY: /proc is a virtual filesystem. Files are generated dynamically from kernel data structures.

**MYTH: "Monolithic kernels are less secure than microkernels"**
REALITY: The security model is more nuanced. Monolithic kernels have fewer privilege boundaries, but microkernels have more complex IPC that can also have vulnerabilities.

**MYTH: "Device files are just configuration"**
REALITY: Device files provide direct access to hardware. Raw disk access (/dev/sda) can bypass file permissions entirely.

**MYTH: "Linux is just the kernel"**
REALITY: What we call "Linux" is usually GNU/Linux—the Linux kernel plus GNU userland tools plus a distribution's additions.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Draw** the Linux architecture layers from hardware to applications
2. **Navigate** /proc and /sys to gather system information
3. **Explain** "everything is a file" with concrete examples
4. **Identify** security-relevant directories and files
5. **Distinguish** between kernel, shell, and userland

---

## 7. Further Depth (Optional)

*   **Reading:** Linux Kernel Development by Robert Love
*   **Practice:** Explore /proc for running processes, extract useful information
*   **Research:** Study how rootkits hide in the kernel module space
*   **Advanced:** Compile a custom Linux kernel with specific options
