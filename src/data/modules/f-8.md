# Introduction to Computing Systems

## 1. Orientation

### What this module covers
This module examines how computers work at the system level—from the moment you press the power button through the boot process to a running operating system. Understanding this chain is foundational: every security control, every attack technique, and every persistence mechanism operates within this architecture.

### Fit in the Learning Path
You cannot understand persistence mechanisms without understanding where code can live across reboots. You cannot analyze rootkits without understanding the boot chain. This module provides the architectural foundation that makes advanced topics comprehensible.

### Learning Objectives
By the end of this module, you will:
*   Trace the complete boot sequence from hardware to user space
*   Understand the security implications at each boot stage
*   Identify how attackers target different levels of the boot chain
*   Apply diagnostic commands to inspect system initialization

---

## 2. Core Content

### Mental Model: The Chain of Trust

**How professionals think about this:**
A computer boots through a chain of components, each loading and trusting the next. Security depends on this chain being unbroken—if any link is compromised, everything that follows is compromised. This is why firmware attacks are so devastating.

```
BOOT CHAIN OF TRUST:

┌─────────────────────────────────────────────────────────────────────┐
│                         POWER ON                                    │
│               (Electricity stabilizes, CPU reset)                   │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    FIRMWARE (UEFI/BIOS)                            │
│  • First code to execute (stored in flash chip on motherboard)     │
│  • POST: Verifies hardware functionality                           │
│  • Locates and loads bootloader                                    │
│  • ATTACK: UEFI rootkits, firmware implants                        │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ (Secure Boot verification)
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      BOOTLOADER                                     │
│  • GRUB (Linux), Windows Boot Manager, etc.                        │
│  • Lives in first sectors of boot disk                             │
│  • Loads kernel into memory                                        │
│  • ATTACK: Bootkits, MBR/VBR infections                            │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ (Optional: Measured Boot)
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        KERNEL                                       │
│  • Core of the operating system                                    │
│  • Takes control of hardware from firmware                         │
│  • Initializes drivers, memory management, scheduler               │
│  • ATTACK: Kernel rootkits, driver-level malware                   │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      USER SPACE (Init)                              │
│  • First user-mode process (PID 1)                                 │
│  • Linux: systemd, init, openrc                                    │
│  • Windows: smss.exe → csrss.exe → winlogon.exe                    │
│  • Starts all services and user applications                       │
│  • ATTACK: Service hijacking, startup persistence                  │
└─────────────────────────────────────────────────────────────────────┘
```

### BIOS vs UEFI

**BIOS (Legacy):**
- Basic Input/Output System
- 16-bit, 1 MB address space limit
- MBR (Master Boot Record) partitioning
- Limited security features
- Being phased out

**UEFI (Modern):**
- Unified Extensible Firmware Interface
- 32/64-bit, full memory access
- GPT (GUID Partition Table) support
- Secure Boot capability
- Supports pre-boot networking, graphics
- EFI System Partition (ESP)

**Security comparison:**

| Aspect | BIOS | UEFI |
|--------|------|------|
| Secure Boot | No | Yes (optional) |
| Code signing | No | Yes |
| Boot verification | None | Signature checking |
| Attack surface | Smaller (simpler) | Larger (complex) |
| Recovery | Harder | Easier (backup ESP) |

### Secure Boot and the Trust Chain

**How Secure Boot works:**
1. UEFI firmware contains trusted keys (Platform Key, KEK)
2. Bootloader must be signed with trusted key
3. Bootloader verifies kernel signature
4. Kernel verifies driver signatures
5. Unsigned code is rejected

**Trust chain visualization:**
```
Platform Key (PK)           ← OEM/User controls this
        │
        ▼
Key Exchange Key (KEK)      ← Authorizes signature database changes
        │
        ▼
Signature Database (db)     ← Contains trusted certificates
        │
        ▼
Bootloader signed by cert   ← GRUB, Windows Boot Manager
        │
        ▼
Kernel signed by cert       ← vmlinuz, ntoskrnl.exe
```

**Attacks that Secure Boot prevents:**
- Boot sector infections
- Unsigned bootloader replacement
- Kernel modification

**Attacks that bypass Secure Boot:**
- Compromised signing keys (leaked or stolen)
- Vulnerabilities in Secure Boot implementation
- Physical access to disable Secure Boot
- Attacking components after the checked chain

### Von Neumann Architecture

**The fundamental computer design:**
```
┌─────────────────────────────────────────────────────────────┐
│                         CPU                                 │
│  ┌────────────────┐    ┌────────────────────┐              │
│  │ Control Unit   │    │ ALU (Arithmetic    │              │
│  │ (Instruction   │    │  Logic Unit)       │              │
│  │  Decode)       │    │ (Computation)      │              │
│  └────────────────┘    └────────────────────┘              │
│                    ┌────────────────┐                      │
│                    │   Registers    │                      │
│                    │ (Fast storage) │                      │
│                    └────────────────┘                      │
└──────────────────────────┬──────────────────────────────────┘
                           │ BUS (Data highway)
     ┌─────────────────────┼─────────────────────┐
     │                     │                     │
     ▼                     ▼                     ▼
┌─────────┐         ┌─────────────┐       ┌───────────────┐
│  RAM    │         │  I/O        │       │  Storage      │
│ (Fast,  │         │ (Keyboard,  │       │ (Disk, SSD)   │
│  temp)  │         │  Network)   │       │ (Slow, perm)  │
└─────────┘         └─────────────┘       └───────────────┘
```

**Key insight for security:**
In Von Neumann architecture, code and data share the same memory. This is why buffer overflows can become code execution—data written by attacker can become instructions executed by CPU.

### The Fetch-Decode-Execute Cycle

**How the CPU processes instructions:**
```
     ┌────────────────────────────────────────┐
     │                                        │
     ▼                                        │
┌─────────┐     ┌─────────┐     ┌─────────┐   │
│  FETCH  │────►│ DECODE  │────►│ EXECUTE │───┘
│         │     │         │     │         │
│ Get next│     │ What    │     │ Do it   │
│ instruc-│     │ does it │     │         │
│ tion    │     │ mean?   │     │         │
└─────────┘     └─────────┘     └─────────┘
```

**Modern complications:**
- Pipelining: Multiple instructions in flight
- Out-of-order execution: CPU reorders for efficiency
- Speculative execution: Guess and execute ahead
- Caching: Multiple levels (L1, L2, L3)

**Security implications:**
- Spectre/Meltdown exploited speculative execution
- Cache timing attacks measure access times
- Side channels leak information through CPU behavior

### Windows vs Linux Boot Comparison

**Windows boot sequence:**
```
UEFI/BIOS → bootmgfw.efi → winload.efi → ntoskrnl.exe → smss.exe →
csrss.exe + wininit.exe → services.exe → svchost.exe instances →
winlogon.exe → User login → explorer.exe
```

**Linux boot sequence:**
```
UEFI/BIOS → GRUB (grub.efi) → vmlinuz (kernel) → initramfs →
init/systemd (PID 1) → target services → getty/login manager →
User session
```

**Comparison:**

| Aspect | Windows | Linux |
|--------|---------|-------|
| Bootloader | Windows Boot Manager | GRUB, systemd-boot |
| Kernel | ntoskrnl.exe | vmlinuz |
| First process | smss.exe → csrss.exe | systemd/init (PID 1) |
| Init system | Service Control Manager | systemd/SysVinit/OpenRC |
| Service daemon | svchost.exe | Individual service daemons |

### Persistence at Each Level

**Attackers choose persistence based on stealth vs complexity:**

| Level | Persistence Method | Difficulty | Detection |
|-------|-------------------|------------|-----------|
| Firmware | UEFI rootkit | Very hard | Very hard |
| Bootloader | MBR/VBR infection | Moderate | Moderate |
| Kernel | Loadable kernel module | Moderate | Moderate |
| Services | Service installation | Easy | Easy |
| Startup | Autoruns, scheduled tasks | Easy | Easy |

---

## 3. Guided Practice

### Exercise 1: Analyzing Boot Messages

Inspect what happened when your Linux VM booted:

```bash
# View kernel ring buffer (boot messages)
dmesg | head -50

# View boot time events
journalctl -b | head -100

# View system initialization
systemd-analyze blame
```

Record your observations:
- What hardware was detected? ___
- How long did boot take? ___
- What services started first? ___

### Exercise 2: Identifying PID 1

```bash
# What is process 1?
ps -p 1 -o comm,args

# View process tree
pstree -p | head -30
```

Questions:
1. What is the name of PID 1 on your system? ___
2. What would happen if PID 1 crashed? ___
3. Why can't you kill PID 1? ___

### Exercise 3: Boot Configuration

```bash
# View bootloader configuration (Linux)
cat /etc/default/grub

# View EFI boot entries (if UEFI)
efibootmgr -v
```

Questions:
1. What kernel parameters are passed at boot? ___
2. What boot options are available? ___

---

## 4. Reflection Check

### Architecture Thinking
1. Why is firmware compromise more serious than user-space malware? What makes it harder to detect and remediate?

2. In the Von Neumann model, code and data share memory. How does this architectural decision enable buffer overflow attacks?

3. Why do modern CPUs have speculative execution, and why did it become a security problem (Spectre/Meltdown)?

### Security Implications
1. If Secure Boot is enabled, can malware still persist across reboots? How?

2. Why might an attacker prefer kernel-level persistence over service-level persistence?

3. You're investigating a suspected firmware rootkit. What artifacts can you check, and what challenges will you face?

---

## 5. Key Misconceptions

**MYTH: "UEFI is inherently more secure than BIOS"**
REALITY: UEFI has security features (Secure Boot), but also a larger attack surface. Complex firmware means more potential vulnerabilities.

**MYTH: "Secure Boot protects against all boot attacks"**
REALITY: Secure Boot verifies signatures. Signed-but-vulnerable bootloaders, disabled Secure Boot, and post-boot attacks still work.

**MYTH: "Reinstalling the OS removes all malware"**
REALITY: Firmware-level and boot-sector malware survive OS reinstallation. Full remediation may require firmware reflashing.

**MYTH: "Only nation-states have firmware malware capability"**
REALITY: UEFI bootkits are now available in commodity malware. The bar has lowered significantly.

**MYTH: "The operating system is the first code to run"**
REALITY: Firmware runs first. By the time the OS loads, significant processing has already occurred.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Trace** the complete boot sequence from power-on to user space
2. **Explain** the security role of each boot stage
3. **Identify** where attackers target the boot chain and why
4. **Inspect** boot logs and configuration on Linux systems
5. **Differentiate** between BIOS/UEFI and explain Secure Boot

---

## 7. Further Depth (Optional)

*   **Research:** Study the UEFI specification and EFI System Partition structure
*   **Practice:** Modify GRUB configuration and observe changes
*   **Exploration:** Research real-world UEFI rootkits (LoJax, MosaicRegressor)
*   **Advanced:** Learn about TPM (Trusted Platform Module) and measured boot
