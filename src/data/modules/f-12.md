# User Space vs Kernel Space

## 1. Orientation

### What this module covers
This module examines the fundamental security boundary in computing: the separation between user-mode code (applications) and kernel-mode code (the operating system core). Understanding this boundary is essential—privilege escalation often means crossing from Ring 3 to Ring 0, and rootkits demonstrate what happens when this boundary is compromised.

### Fit in the Learning Path
This module formalizes concepts introduced earlier and explains why operating systems are designed the way they are. The user/kernel boundary is the primary defense mechanism that allows untrusted applications to run without compromising system integrity.

### Learning Objectives
By the end of this module, you will:
*   Understand CPU protection rings and their purpose
*   Explain how system calls cross the user/kernel boundary
*   Recognize why kernel-mode access is the ultimate privilege
*   Analyze security implications of kernel-mode malware

---

## 2. Core Content

### Mental Model: The Trust Boundary

**How professionals think about this:**
The kernel is the trusted computing base (TCB). It must be protected from applications because applications can be malicious, buggy, or compromised. The CPU hardware enforces this boundary—even a perfectly crafted attack in user space cannot directly access kernel memory.

```
TRUST MODEL:

┌─────────────────────────────────────────────────────────────────────┐
│                         UNTRUSTED ZONE                              │
│                        (User Space / Ring 3)                        │
│                                                                     │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐               │
│  │ Firefox │  │  Vim    │  │ Malware │  │ Python  │               │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘               │
│                                                                     │
│  Can crash, be exploited, run untrusted code                       │
│  CANNOT directly access hardware, kernel memory, other processes   │
└──────────────────────────────┬──────────────────────────────────────┘
                               │ System Calls (controlled gate)
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│                          TRUSTED ZONE                               │
│                       (Kernel Space / Ring 0)                       │
│                                                                     │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │                         KERNEL                                 │ │
│  │  Memory Manager │ Scheduler │ Device Drivers │ File System   │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  Full hardware access, all memory visible, ultimate authority       │
└─────────────────────────────────────────────────────────────────────┘
```

### CPU Protection Rings

**x86 architecture defines 4 rings, but modern OSes use 2:**

```
                    ┌─────────────────┐
                    │     RING 0      │ ← Kernel Mode
                    │  (Most trusted) │   • Full hardware access
                    │                 │   • All CPU instructions
                    │     Kernel      │   • All memory visible
                    ├─────────────────┤
                    │     RING 1      │ ← Historically for OS services
                    │   (Unused)      │   • Rarely used in practice
                    ├─────────────────┤
                    │     RING 2      │ ← Historically for device drivers
                    │   (Unused)      │   • Rarely used in practice
                    ├─────────────────┤
                    │     RING 3      │ ← User Mode
                    │ (Least trusted) │   • Restricted instructions
                    │                 │   • Cannot access kernel memory
                    │  Applications   │   • Must use syscalls for I/O
                    └─────────────────┘
```

**What Ring 3 CANNOT do:**
- Execute privileged CPU instructions (I/O ports, page table manipulation)
- Access physical memory directly
- Read/write kernel memory
- Access other processes' memory
- Interact directly with hardware

**The hardware enforces this:**
If user-mode code attempts a privileged operation, the CPU generates an exception. The kernel handles the exception—typically by killing the offending process.

### System Calls: The Controlled Gate

**The only legitimate way to cross the boundary:**

Applications need OS services (file I/O, networking, process creation). They request these through system calls—a controlled interface where the kernel validates and performs the operation.

```
APPLICATION WANTS TO READ A FILE:

┌──────────────────────────────────────────────────────────────────┐
│ User Space (Ring 3)                                              │
│                                                                  │
│  Application: read(fd, buffer, size)                            │
│       │                                                          │
│       │ 1. Set up arguments in registers                        │
│       │ 2. Trigger syscall instruction                          │
│       ▼                                                          │
│  ════════════════════════════════════════════════════════════    │
│  CPU RING TRANSITION (Hardware enforced)                        │
│  ════════════════════════════════════════════════════════════    │
│       │ 3. Switch to Ring 0                                     │
│       │ 4. Jump to kernel syscall handler                       │
│       ▼                                                          │
└──────────────────────────────────────────────────────────────────┘
┌──────────────────────────────────────────────────────────────────┐
│ Kernel Space (Ring 0)                                            │
│                                                                  │
│  5. Kernel validates: Does process own this fd?                 │
│  6. Kernel reads from disk/cache                                │
│  7. Kernel copies data to user buffer                           │
│  8. Return to user space                                        │
│       │                                                          │
│       ▼                                                          │
│  ════════════════════════════════════════════════════════════    │
│  Return to Ring 3                                                │
│  ════════════════════════════════════════════════════════════    │
└──────────────────────────────────────────────────────────────────┘
```

**Common system calls:**

| Category | Examples | Purpose |
|----------|----------|---------|
| **File I/O** | open, read, write, close | File operations |
| **Process** | fork, exec, exit, wait | Process management |
| **Memory** | mmap, brk, mprotect | Memory management |
| **Network** | socket, connect, send, recv | Networking |
| **System** | ioctl, sysinfo | System control |

### The Cost of Crossing

**Context switching is expensive:**
- Save all user registers
- Switch page tables
- Flush TLBs (potentially)
- Execute kernel code
- Restore and return

This overhead is why:
- High-performance I/O uses techniques like io_uring to reduce syscall count
- Memory-mapped I/O is faster than read()/write() calls
- Syscall overhead matters for high-frequency operations

### Crashes: User vs Kernel

**User-space crash:**
```
Application bug → Segmentation fault
       │
       ▼
Kernel catches signal, terminates process
       │
       ▼
System continues, other processes unaffected
```

**Kernel-space crash:**
```
Kernel bug → No one to catch it
       │
       ▼
Immediate system halt (Kernel Panic / BSOD)
       │
       ▼
Data corruption prevention by stopping
```

**Why kernel crashes are catastrophic:**
- The kernel is the error handler—no one handles kernel errors
- Continuing with corrupted kernel state could destroy data
- Hardware access means memory corruption is possible

### Security Implications

**The kernel-mode goal:**
Attackers who achieve kernel-mode code execution have won completely:
- Can hide files, processes, network connections (rootkit)
- Can intercept all data (keylogger, credential theft)
- Can persist undetectably (kernel-mode persistence)
- Can bypass all security software (antivirus runs in user mode)

**Attack paths to Ring 0:**

| Vector | Description | Example |
|--------|-------------|---------|
| Kernel exploit | Bug in kernel code | Dirty COW, CVE-2021-4034 |
| Driver exploit | Bug in device driver | Vulnerable GPU driver |
| Hypervisor exploit | Escape VM to host | VENOM, CVE-2015-3456 |
| Bootkit | Load before kernel | LoJax, UEFI rootkits |

**Defense mechanisms:**

| Defense | Purpose |
|---------|---------|
| SMEP | Prevent kernel from executing user-space code |
| SMAP | Prevent kernel from accessing user-space memory |
| KASLR | Randomize kernel memory layout |
| Driver signing | Only load signed drivers |
| Secure Boot | Verify boot chain integrity |

### Virtualization and Hypervisors

**Adding another layer:**
Hypervisors create a level below the kernel:

```
                    ┌─────────────────┐
                    │     RING -1     │ ← Hypervisor (VMM)
                    │   (Intel VT-x)  │   • Controls VMs
                    ├─────────────────┤
                    │     RING 0      │ ← Guest Kernel
                    │                 │   • Thinks it's Ring 0
                    ├─────────────────┤
                    │     RING 3      │ ← Guest User Space
                    │                 │   
                    └─────────────────┘
```

**Security implication:**
Hypervisor exploits (VM escape) are more severe than kernel exploits because they break the entire virtualization boundary.

---

## 3. Guided Practice

### Exercise 1: Observing System Calls

Trace a simple command:

```bash
# Trace ls command
strace ls 2>&1 | head -50

# Trace with counts
strace -c ls

# Trace specific syscalls
strace -e read,write,open cat /etc/passwd
```

Questions:
1. What syscall does ls use to read directory contents? ___
2. Approximately how many syscalls does `ls` make? ___
3. What's the most frequent syscall? ___

### Exercise 2: Ring Detection

Determine the privilege level:

```bash
# User space process
ps aux | grep -E "chrome|firefox"

# Kernel threads (look for brackets)
ps aux | grep -E "^\[.*\]$"

# Kernel modules (drivers)
lsmod | head -10
```

Questions:
1. Are kernel threads visible in ps output? ___
2. What are some kernel modules loaded on your system? ___

### Exercise 3: Crash Comparison

**User crash (safe to do):**
```bash
# Create a crash
python3 -c "import ctypes; ctypes.string_at(0)"
```
Observe: The terminal continues. Only python crashed.

**Kernel crash (DO NOT DO THIS - explanation only):**
```bash
# This would crash the system (DON'T RUN):
# echo c > /proc/sysrq-trigger
```
The difference: Kernel crashes halt the entire system.

---

## 4. Reflection Check

### Architecture Understanding
1. Why can't an application simply jump to kernel memory addresses? What prevents it?

2. If system calls are slow due to context switching, why don't applications access hardware directly?

3. A driver bug crashes the system even though drivers are "just software." Why?

### Security Thinking
1. Why do antivirus programs running in Ring 3 have difficulty detecting Ring 0 rootkits?

2. What's the security implication of "driver signing requirements" in Windows?

3. SMEP prevents the kernel from executing user-space code. What attack technique did this break?

---

## 5. Key Misconceptions

**MYTH: "Applications directly access hardware devices"**
REALITY: Applications request services through syscalls. The kernel performs actual hardware I/O.

**MYTH: "Root/Administrator runs in kernel mode"**
REALITY: Root is still Ring 3. It just has all permissions. Kernel exploits are still needed for Ring 0.

**MYTH: "Antivirus can detect all malware"**
REALITY: User-mode antivirus cannot reliably inspect kernel memory. Kernel rootkits can hide from it.

**MYTH: "Ring 0 and Ring 3 are Windows concepts"**
REALITY: Protection rings are CPU hardware features. All operating systems build on them.

**MYTH: "Kernel crashes are just bugs to fix"**
REALITY: Kernel vulnerabilities that allow code execution are critical security issues, not just stability problems.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Draw** the ring privilege model and explain its purpose
2. **Trace** system calls and understand user-kernel transitions
3. **Explain** why kernel-mode access is the ultimate attack goal
4. **Identify** the difference between user-space and kernel-space crashes
5. **Understand** defense mechanisms like SMEP/SMAP/KASLR

---

## 7. Further Depth (Optional)

*   **Research:** Study common Linux kernel CVEs and exploitation techniques
*   **Practice:** Use strace extensively to understand program behavior
*   **Exploration:** Research Spectre/Meltdown as cross-boundary attacks
*   **Advanced:** Study hypervisor architecture and VM escape vulnerabilities
