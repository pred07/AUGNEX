# User Space vs Kernel Space

## Introduction

Modern operating systems are paranoid. They do not trust your programs. To prevent a crashing video game from taking down the entire computer, the memory is split into two zones.

## Kernel Space (Ring 0)

This is the VIP section.
*   **Access**: Full, unrestricted access to all hardware (RAM, Disk, CPU).
*   **Who lives here?**: The OS Kernel, hardware drivers.
*   **Crash consequence**: If code crashes here, the entire computer crashes (Blue Screen of Death / Kernel Panic).

## User Space (Ring 3)

This is the public section.
*   **Access**: Restricted. Cannot touch hardware directly. Must ask the Kernel nicely using **System Calls**.
*   **Who lives here?**: Web browsers, Word processors, Tools (nmap, python), your shell.
*   **Crash consequence**: If code crashes here, only that program closes. The OS stays alive.

## The Boundary: System Calls (syscalls)

When your program wants to read a file, it can't just read the hard drive.
1.  Program (User Space) asks: "Hey Kernel, open `file.txt`."
2.  Switch to Kernel Mode (Context Switch).
3.  Kernel checks permissions: "Does this user own this file?"
4.  If yes, Kernel reads the data.
5.  Kernel passes data back to Program.
6.  Switch back to User Mode.

## Why This Matters

*   **Exploitation**: Most exploits run in **User Space** (getting a shell).
*   **Privilege Escalation**: Often attacks the kernel to get from User Space -> Kernel Space.
*   **Rootkits**: Malware that installs itself in **Kernel Space** is invisible because it controls the very eyes of the OS.
