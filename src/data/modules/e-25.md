# Authorization Attacks (IDOR and Access Control)

## 1. Orientation

### What this module covers
This module covers authorization vulnerabilities—specifically IDOR (Insecure Direct Object Reference) and broken access control. These vulnerabilities occur when the application fails to verify that a user has permission to access the specific resource they're requesting.

### Fit in the Learning Path
IDORs are extremely common and often critical, exposing sensitive data (PII, financial records) or enabling account takeover. They represent authorization failures (Can I access this?) rather than authentication failures (Who am I?).

### Learning Objectives
By the end of this module, you will:
*   Understand IDOR and BOLA concepts
*   Identify authorization vulnerabilities systematically
*   Distinguish horizontal and vertical privilege escalation
*   Test access controls effectively

---

## 2. Core Content

### Mental Model: Authentication vs Authorization

**How professionals think about this:**
Authentication verifies WHO you are. Authorization verifies WHAT you can do. IDOR occurs when authorization checks are missing or insufficient—the system knows who you are but doesn't verify your permission to access specific objects.

```
IDOR CONCEPT:

AUTHENTICATION (Working):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  User: alice@example.com                                           │
│  Password: ********                                                 │
│  Session: authenticated as Alice (user_id=100)                     │
│                                                                     │
│  ✓ System knows WHO Alice is                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

AUTHORIZATION (Broken):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  Request: GET /api/invoices/200                                    │
│  Alice's user_id: 100                                              │
│  Invoice 200 belongs to: Bob (user_id=150)                         │
│                                                                     │
│  Server logic:                                                     │
│  ┌────────────────────────────────────────┐                        │
│  │ if (user.authenticated) {              │                        │
│  │     return Invoice.findById(200);  ← No ownership check!       │
│  │ }                                      │                        │
│  └────────────────────────────────────────┘                        │
│                                                                     │
│  Result: Alice sees Bob's invoice                                  │
│  ✗ System didn't verify WHAT Alice should access                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Privilege Escalation Types

**Horizontal vs Vertical:**

```
PRIVILEGE ESCALATION:

HORIZONTAL (Same role, different user):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  User A (Regular User) ──────► User B's Data (Regular User)       │
│                                                                     │
│  Example: Alice views Bob's profile, orders, messages              │
│  Impact: Privacy breach, data theft                                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

VERTICAL (Lower role, higher privilege):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  User (Regular) ──────► Admin Functions                            │
│                                                                     │
│  Example: Regular user accesses /admin/users/delete                │
│  Impact: Full system compromise                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

CONTEXT ESCALATION (Same user, different context):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  User (Org A) ──────► Resources in Org B                           │
│                                                                     │
│  Example: User in Company A accesses Company B's data              │
│  Impact: Cross-tenant data breach                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Common IDOR Patterns

**Where IDORs hide:**

| Location | Example | Attack |
|----------|---------|--------|
| **URL path** | `/users/123/profile` | Change 123 to 124 |
| **Query parameter** | `?user_id=123` | Change to 124 |
| **POST body** | `{"user_id": 123}` | Change value |
| **Headers** | `X-User-ID: 123` | Change header |
| **Cookies** | `user=123` | Change cookie |
| **Filename** | `/files/user123_doc.pdf` | Change filename |
| **API version** | `/v2/users` vs `/v1/users` | Old version unprotected |

**ID types:**

```
IDENTIFIER TYPES:

SEQUENTIAL (Easy to enumerate):
user_id=1, 2, 3, 4...
order_id=1000, 1001, 1002...

ENCODED (Easily decoded):
user_id=MTIz (Base64 of "123")
order_id=7b226964223a313233fD (JSON in Base64)

UUID (Harder to guess, but...):
user_id=550e8400-e29b-41d4-a716-446655440000
- If leaked in URLs, referrers, logs → exploitable
- If generated weakly → predictable
- Still vulnerable if no access control

HASHED:
user_id=a665a45920422f9d...  (SHA256 of ID)
- If salt is known or no salt → rainbow table
- Still vulnerable to IDOR if hash leaked

KEY INSIGHT: Obscure identifiers PREVENT ENUMERATION
             They DO NOT PROVIDE ACCESS CONTROL
```

### Testing Methodology

**Systematic IDOR hunting:**

```
IDOR TESTING WORKFLOW:

STEP 1: CREATE MULTIPLE ACCOUNTS
──────────────────────────────────
Account A: attacker@test.com (user_id=100)
Account B: victim@test.com (user_id=101)

STEP 2: MAP ALL IDENTIFIERS
──────────────────────────────────
Browse as Account A, record all IDs:
- Profile: /users/100
- Orders: /orders/5001
- Messages: /messages/msg_abc123
- Documents: /docs/doc_xyz

STEP 3: GET VICTIM'S IDENTIFIERS
──────────────────────────────────
Browse as Account B, record IDs:
- Profile: /users/101
- Orders: /orders/5002
- Messages: /messages/msg_def456
- Documents: /docs/doc_uvw

STEP 4: CROSS-TEST
──────────────────────────────────
As Account A, request Account B's resources:
GET /users/101 → Should fail, does it?
GET /orders/5002 → Should fail, does it?
GET /messages/msg_def456 → Should fail, does it?

STEP 5: TEST ALL HTTP METHODS
──────────────────────────────────
GET /users/101 → Blocked
PUT /users/101 → Blocked?
DELETE /users/101 → Blocked?
PATCH /users/101 → Blocked?
```

### API-Specific IDOR (BOLA)

**Broken Object Level Authorization:**

```
API IDOR PATTERNS:

REST API:
GET /api/users/123/account
PUT /api/users/123/account {"balance": 10000}
DELETE /api/users/123

GraphQL:
query {
  user(id: "123") {
    email
    ssn
    creditCards { number }
  }
}

BOLA in mutations:
mutation {
  updateUser(id: "123", admin: true) {
    id
  }
}

MASS ASSIGNMENT + IDOR:
PUT /api/users/123
{"id": 123, "email": "new@email.com", "role": "admin", "user_id": 456}
                                        ↑ Added       ↑ Changed user
```

### Advanced IDOR Techniques

**Bypasses and edge cases:**

```
IDOR BYPASS TECHNIQUES:

1. PARAMETER POLLUTION
   /api/users/123?user_id=456
   Body: {"user_id": 789}
   Which one does the server use?

2. HTTP METHOD SWITCHING
   GET /api/users/123 → 403 Forbidden
   POST /api/users/123 → 200 OK (different handler)

3. CASE SENSITIVITY
   /api/Users/123 vs /api/users/123

4. ENCODING VARIATIONS
   /api/users/123
   /api/users/123%00
   /api/users/123.json
   /api/users/123/

5. INDIRECT REFERENCES
   Direct: /orders/5001
   Indirect: /my-orders (uses session) → Export feature → /export?order_id=5001

6. VERSION DOWNGRADE
   /api/v2/users/123 → Access control
   /api/v1/users/123 → No access control (legacy)

7. ALTERNATIVE ENDPOINTS
   /api/users/123 → Blocked
   /api/admin/users/123 → Works (forgot to protect)
   /internal/users/123 → Works
```

### IDOR Impact Scenarios

**Critical to Low:**

| Scenario | Impact | Severity |
|----------|--------|----------|
| Access other users' SSN, CC | Data breach, identity theft | Critical |
| Change other users' password | Account takeover | Critical |
| Delete other users' accounts | Denial of service, data loss | High |
| Access other users' orders | Privacy violation | Medium-High |
| View other users' public profiles | Usually intended | Low |
| Access admin functions | Full compromise | Critical |

### Prevention Patterns

**What proper access control looks like:**

```python
# VULNERABLE CODE:
@app.route('/api/invoices/<invoice_id>')
def get_invoice(invoice_id):
    # Only checks authentication, not authorization!
    invoice = Invoice.query.get(invoice_id)
    return jsonify(invoice.to_dict())

# SECURE CODE:
@app.route('/api/invoices/<invoice_id>')
def get_invoice(invoice_id):
    invoice = Invoice.query.get(invoice_id)
    
    # Authorization check: Does this user own this invoice?
    if invoice.user_id != current_user.id:
        abort(403, "Access denied")
    
    return jsonify(invoice.to_dict())

# EVEN BETTER - Query scoping:
@app.route('/api/invoices/<invoice_id>')
def get_invoice(invoice_id):
    # Query only returns invoices belonging to current user
    invoice = Invoice.query.filter_by(
        id=invoice_id,
        user_id=current_user.id  # Scoped to user
    ).first_or_404()
    
    return jsonify(invoice.to_dict())
```

---

## 3. Guided Practice

### Exercise 1: IDOR Identification

Given these endpoints, identify potential IDOR risks:

| Endpoint | Risk? | Attack |
|----------|-------|--------|
| `GET /api/users/me` | ___ | ___ |
| `GET /api/users/123` | ___ | ___ |
| `PUT /api/orders/456/status` | ___ | ___ |
| `DELETE /api/comments/789` | ___ | ___ |

### Exercise 2: Test Case Design

For an e-commerce site with user profiles, orders, and reviews:

Design IDOR test cases:

1. ___
2. ___
3. ___
4. ___

### Exercise 3: Impact Assessment

You found you can:
1. View any user's order history
2. Change any user's email address
3. Delete any user's saved payment methods

Rate severity and explain:

| Finding | Severity | Justification |
|---------|----------|---------------|
| View orders | ___ | ___ |
| Change email | ___ | ___ |
| Delete payments | ___ | ___ |

---

## 4. Reflection Check

### Understanding IDORs
1. UUIDs are used instead of sequential IDs. Is IDOR still possible?

2. An endpoint requires authentication but has IDOR. What's missing?

3. You found IDOR on a "read" endpoint. Should you test "write" endpoints too?

### Attack Thinking
1. The application uses encoded IDs (Base64). How do you test for IDOR?

2. You can only access your own orders via `/my-orders`. How might you still find IDOR?

3. API v2 is protected. Why should you test API v1?

---

## 5. Key Misconceptions

**MYTH: "UUIDs prevent IDOR"**
REALITY: UUIDs prevent enumeration (guessing), not access. If you obtain a UUID, IDOR still works.

**MYTH: "Authentication means authorization is handled"**
REALITY: Authentication = Who are you? Authorization = What can you access? Separate concerns.

**MYTH: "Only GET requests are vulnerable"**
REALITY: PUT, POST, DELETE, PATCH can all have IDOR. Write operations often worse impact.

**MYTH: "Scanners find IDORs"**
REALITY: Scanners can't determine resource ownership. IDOR testing requires business logic understanding.

**MYTH: "Internal APIs don't need access control"**
REALITY: Internal APIs are still reachable. All APIs need authorization.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Explain** IDOR and BOLA concepts
2. **Distinguish** horizontal vs vertical privilege escalation
3. **Test** endpoints systematically for authorization flaws
4. **Identify** IDOR in various ID formats (sequential, encoded, UUID)
5. **Apply** proper access control patterns

---

## 7. Further Depth (Optional)

*   **Practice:** OWASP Juice Shop, Damn Vulnerable Web App
*   **Research:** BOLA in OWASP API Top 10
*   **Tool:** Autorize Burp extension for automated auth testing
*   **Bug Bounty:** Study IDOR reports on HackerOne/Bugcrowd
