# Python for Security: Sockets & Automation

## 1. Orientation

### What this module covers
Going lower level. While `requests` handles HTTP, `socket` handles raw networking (TCP/UDP). This is essential for understanding how port scanners, reverse shells, and exploit payloads work across the wire.

### Learning Objectives
*   Understand the Client-Server model.
*   Create a creating TCP connection using `socket`.
*   Implement Exception Handling for robust tools.
*   Build a simple Port Scanner.

---

## 2. Core Content

### The Socket Object
A socket is an endpoint for sending or receiving data.

```python
import socket

# Create socket (IPv4, TCP)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect to target
s.connect(("192.168.1.5", 22))

# Receive Banner
banner = s.recv(1024)
print(banner.decode())

# Close
s.close()
```

### Exception Handling
Networks are messy. Hosts go down. Packets drop. Scripts must not crash.

```python
try:
    s.connect((ip, port))
except ConnectionRefusedError:
    print("Port is closed.")
except socket.timeout:
    print("Host timed out.")
```

### Automation logic
Combine Loops + Sockets = Scanner.

---

## 3. Lab: The Port Scanner

### Task
Build a threaded port scanner is complex, but start with a linear one.

```python
import socket

target = "192.168.1.10"
ports = [21, 22, 80, 443, 3389]

print(f"Scanning {target}...")

for port in ports:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1)
    result = s.connect_ex((target, port)) # Returns 0 if success
    if result == 0:
        print(f"Port {port}: OPEN")
    s.close()
```

---

## 4. Reflection
1.  Why do we need `.decode()` on receive? (Sockets transmit bytes; we need strings).
2.  What is `AF_INET`? (Address Family for IPv4).
