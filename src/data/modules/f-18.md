# Pipes, Redirection, and Environment Variables

## 1. Orientation

### What this module covers
This module covers the core mechanics of data flow in Unix-like systems—pipes, redirection, and environment variables. These foundational concepts enable powerful command chaining, automation, and form the basis for many security operations.

### Fit in the Learning Path
The Unix philosophy is "write programs that do one thing well, and work together." Command chaining through pipes and redirection is how security professionals build powerful workflows from simple tools.

### Learning Objectives
By the end of this module, you will:
*   Understand standard streams (stdin, stdout, stderr)
*   Chain commands effectively with pipes
*   Redirect output to files and other processes
*   Manipulate environment variables

---

## 2. Core Content

### Mental Model: Streams and Channels

**How professionals think about this:**
Every program has three standard channels. Understanding these streams and how to redirect them is fundamental to shell mastery and automation.

```
STANDARD STREAMS:

┌─────────────────────────────────────────────────────────────────────┐
│                          PROGRAM                                    │
│                                                                     │
│     STDIN (0)              [Processing]            STDOUT (1)      │
│   ───────►                                        ───────►         │
│   Keyboard                                        Screen           │
│                                                                     │
│                                                   STDERR (2)       │
│                                                   ───────►         │
│                                                   Screen (errors)  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

File Descriptor Numbers:
0 = stdin  (standard input)
1 = stdout (standard output)
2 = stderr (standard error)
```

### Pipes: Connecting Commands

**The pipe operator:**

```
PIPE MECHANICS:

Command A          |         Command B
   │                           │
   └──── stdout ───────► stdin ─┘

Example: ls | grep ".txt"

ls                 |         grep ".txt"
  │                           │
  └──── file listing ───► stdin ─┘
                                │
                                └──► lines with ".txt"
```

**Common pipe patterns:**

```bash
# Filter output
command | grep "pattern"

# Count lines
command | wc -l

# Sort output
command | sort

# Remove duplicates
command | sort | uniq

# Page through output
command | less

# Select columns
command | awk '{print $1}'

# Multiple pipes (pipeline)
cat access.log | grep "404" | awk '{print $1}' | sort | uniq -c | sort -rn
# Result: Count of 404 errors by IP, sorted by frequency
```

**Security-relevant pipe examples:**

```bash
# Find processes listening on ports
netstat -tuln | grep LISTEN

# Extract unique IPs from log
cat access.log | grep -oE "\b[0-9]{1,3}(\.[0-9]{1,3}){3}\b" | sort -u

# Find world-writable files
find / -perm -002 -type f 2>/dev/null | head -20

# Process nmap output
nmap -sn 192.168.1.0/24 | grep "Nmap scan" | cut -d' ' -f5 > live_hosts.txt

# Find sensitive files
find / -name "*.conf" -o -name "*.env" 2>/dev/null | xargs grep -l "password"
```

### Output Redirection

**Operators:**

| Operator | Function |
|----------|----------|
| `>` | Redirect stdout to file (overwrite) |
| `>>` | Redirect stdout to file (append) |
| `2>` | Redirect stderr to file |
| `2>&1` | Redirect stderr to where stdout goes |
| `&>` | Redirect both stdout and stderr |
| `<` | Redirect file to stdin |

**Examples:**

```bash
# Overwrite file with output
ls > files.txt

# Append to file
date >> logfile.txt

# Separate stdout and stderr
command > output.txt 2> errors.txt

# Combine stdout and stderr to file
command > all_output.txt 2>&1
# OR (bash shortcut)
command &> all_output.txt

# Silence stderr
command 2>/dev/null

# Silence everything
command > /dev/null 2>&1

# Read from file
sort < unsorted.txt > sorted.txt

# Here document (inline input)
cat << EOF > config.txt
line 1
line 2
EOF
```

### Input Redirection

**Process Substitution:**

```bash
# Compare two command outputs
diff <(ls dir1) <(ls dir2)

# Feed command output as file
command < <(other_command)

# Multiple inputs
paste <(command1) <(command2)
```

**Here strings and documents:**

```bash
# Here string (single line input)
grep "pattern" <<< "text to search"

# Here document (multi-line input)
cat << 'END'
This is
multi-line
input
END
```

### Environment Variables

**Core concepts:**

```bash
# View all environment variables
env
printenv

# View specific variable
echo $PATH
echo $HOME
echo $USER

# Set variable (current session)
MYVAR="value"

# Export to child processes
export MYVAR="value"

# Set for single command
LANG=C command

# Unset variable
unset MYVAR
```

**Critical environment variables:**

```
ESSENTIAL VARIABLES:

PATH=/usr/local/bin:/usr/bin:/bin
└── Directories searched for executables
    Security: PATH order matters for hijacking

HOME=/home/user
└── User's home directory
    Security: ~ expands to $HOME

USER=username
└── Current username
    Security: Used in path construction

SHELL=/bin/bash
└── User's default shell
    Security: Affects script execution

EDITOR=vim
└── Default editor
    Security: Escape-to-shell in editors

LD_PRELOAD=/path/to/library.so
└── Library loaded before all others
    Security: Used for rootkits, interposition

LD_LIBRARY_PATH=/custom/libs
└── Additional library search paths
    Security: Library injection attacks

HISTFILE=~/.bash_history
└── Shell history location
    Security: Attackers often modify
```

### PATH Security

**Understanding PATH:**

```
PATH MECHANICS:

When you type: ls

Shell checks directories in $PATH order:
1. /usr/local/bin/ls  ← Not found
2. /usr/bin/ls        ← Not found  
3. /bin/ls            ← FOUND! Execute this

If PATH="/tmp:$PATH"
1. /tmp/ls            ← Attacker's version executed!
2. /usr/local/bin/ls
...
```

**PATH hijacking attack:**

```bash
# Attacker creates malicious 'ls' in /tmp
cat > /tmp/ls << 'EOF'
#!/bin/bash
# Malicious payload here
/bin/ls "$@"  # Then run real ls to hide attack
EOF
chmod +x /tmp/ls

# If victim runs script with /tmp in PATH first:
export PATH="/tmp:$PATH"
ls  # Runs attacker's version!

# Prevention: Always use absolute paths in scripts
# Prevention: Don't add writable directories to PATH
```

### Advanced Redirection

**File descriptors:**

```bash
# Open file descriptor
exec 3>output.txt     # Open fd 3 for writing
echo "data" >&3       # Write to fd 3
exec 3>&-             # Close fd 3

# Swap stdout and stderr
command 3>&1 1>&2 2>&3

# Duplicate output to file and terminal
command | tee output.txt

# Append with tee
command | tee -a output.txt
```

**Named pipes (FIFOs):**

```bash
# Create named pipe
mkfifo /tmp/mypipe

# Terminal 1: Write to pipe
echo "message" > /tmp/mypipe

# Terminal 2: Read from pipe
cat < /tmp/mypipe

# Security use: Covert channels
# Attack use: Exfiltration paths
```

### Practical Command Chains

**Log analysis:**

```bash
# Count requests per IP
cut -d' ' -f1 access.log | sort | uniq -c | sort -rn | head

# Find failed SSH logins
grep "Failed password" /var/log/auth.log | \
  grep -oE "from [0-9.]+" | \
  cut -d' ' -f2 | \
  sort | uniq -c | sort -rn

# Time-based analysis
cat access.log | \
  awk '{print $4}' | \
  cut -d: -f2 | \
  sort | uniq -c
```

**System enumeration:**

```bash
# Find SUID binaries
find / -perm -4000 -type f 2>/dev/null | xargs ls -la

# Network connections
ss -tuln | awk 'NR>1 {print $5}' | cut -d: -f1 | sort -u

# Process tree
ps aux | grep -v grep | grep root
```

---

## 3. Guided Practice

### Exercise 1: Pipe Mastery

Complete these one-liners:

```bash
# 1. Find files in /etc containing 'password'
grep -r "password" /etc 2>/dev/null | head

# 2. Count unique users in /etc/passwd
cat /etc/passwd | cut -d: -f1 | wc -l

# 3. Your turn: List listening ports only
netstat -tuln | grep LISTEN | ___
```

### Exercise 2: Redirection

```bash
# Create test file
echo "test content" > test.txt

# Append date
___ >> test.txt

# Run command, save errors separately
find /root -name "*.txt" > results.txt 2> errors.txt

# Verify
cat results.txt
cat errors.txt
```

### Exercise 3: PATH Awareness

```bash
# Check your PATH
echo $PATH

# Where is 'ls' coming from?
which ls
type ls

# Full path prevents hijacking
/bin/ls
```

---

## 4. Reflection Check

### Stream Understanding
1. What's the difference between `>` and `>>`?

2. The command `cmd 2>&1` means what exactly?

3. Why does `find / 2>/dev/null` often produce cleaner output?

### Security Thinking
1. An attacker modifies your PATH to include /tmp first. How do you stay safe?

2. You see `LD_PRELOAD` set to a suspicious library. What's happening?

3. How could named pipes be used for data exfiltration?

---

## 5. Key Misconceptions

**MYTH: "Pipes and redirection are the same"**
REALITY: Pipes connect commands. Redirection connects commands to files.

**MYTH: "> file 2>&1" and "2>&1 > file" are equivalent**
REALITY: Order matters! "2>&1 > file" redirects stderr to original stdout, then stdout to file.

**MYTH: "Environment variables are always inherited"**
REALITY: Only exported variables pass to child processes. Source (.source) runs in current shell.

**MYTH: "/dev/null is a directory"**
REALITY: /dev/null is a null device—a black hole that discards everything written to it.

**MYTH: "PATH starts from current directory"**
REALITY: Most modern systems don't include . in PATH for security reasons.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Explain** stdin, stdout, stderr and their file descriptors
2. **Chain** commands effectively with pipes
3. **Redirect** output to files in various ways
4. **Manipulate** environment variables
5. **Recognize** PATH-based security issues

---

## 7. Further Depth (Optional)

*   **Practice:** Build complex log analysis pipelines
*   **Tool:** Learn xargs for efficient command execution
*   **Security:** Study LD_PRELOAD attacks
*   **Advanced:** Process substitution and file descriptor manipulation
