# Parameter Discovery and Mapping

## 1. Orientation

### What this module covers
This module goes beyond endpoint discovery to find hidden parameters—the keys that unlock additional functionality, debug modes, and often, vulnerabilities. A visible page may hide critical functionality behind undocumented parameters.

### Fit in the Learning Path
Sometimes the page is visible but the vulnerability is hidden behind a parameter that isn't documented. Mass assignment bugs, debug modes, and privilege escalation often live in hidden parameters.

### Learning Objectives
By the end of this module, you will:
*   Discover hidden parameters systematically
*   Identify different parameter contexts
*   Use specialized discovery tools
*   Exploit common hidden parameter patterns

---

## 2. Core Content

### Mental Model: Parameters as Keys

**How professionals think about this:**
Every input parameter is a key that may unlock hidden functionality. Developers add debug flags, admin switches, and internal features through parameters—assuming they'll remain hidden. Your job is to find them.

```
PARAMETER DISCOVERY MODEL:

VISIBLE PAGE:
/page.php
│
├── Documented parameters: ?id=1&page=2
│   └── Normal functionality
│
└── HIDDEN PARAMETERS (What you need to find):
    │
    ├── Debug modes:
    │   ?debug=true
    │   ?test=1
    │   ?verbose=1
    │
    ├── Admin switches:
    │   ?admin=true
    │   ?is_admin=1
    │   ?role=admin
    │
    ├── Feature flags:
    │   ?beta=true
    │   ?preview=1
    │   ?internal=1
    │
    ├── Redirect/SSRF:
    │   ?redirect=url
    │   ?url=
    │   ?next=
    │
    └── Data exposure:
        ?source=
        ?format=json
        ?export=true
```

### Parameter Contexts

**Where parameters live:**

```
PARAMETER LOCATIONS:

1. QUERY STRING (GET)
   /page?param=value&param2=value2
   
2. POST BODY
   param=value&param2=value2
   
3. JSON BODY
   {"param": "value", "hidden_param": true}
   
4. XML BODY
   <param>value</param>
   
5. PATH PARAMETERS
   /api/v1/users/{user_id}/profile
   
6. HEADERS
   X-Custom-Param: value
   
7. COOKIES
   Cookie: param=value
   
8. MULTIPART FORM
   --boundary
   Content-Disposition: form-data; name="param"
```

### Discovery Techniques

**Manual discovery:**

```
MANUAL PARAMETER HUNTING:

1. SOURCE CODE ANALYSIS
   - View JavaScript files
   - Search for parameter names in code
   - Look for API calls with parameters

2. DOCUMENTATION REVIEW
   - API docs sometimes expose internal parameters
   - Swagger/OpenAPI specs
   - GitHub repos, old docs

3. ERROR MESSAGES
   - Errors may reveal expected parameters
   - "Expected parameter 'user_id'"

4. HISTORICAL DATA
   - Wayback Machine
   - Old API versions

5. LOGICAL GUESSING
   - If 'id' works, try 'user_id', 'admin_id'
   - If 'page' works, try 'limit', 'offset'
   - If 'sort' works, try 'order', 'direction'
```

**Common hidden parameters:**

| Category | Parameters |
|----------|------------|
| **Debug** | debug, test, verbose, trace, profile, dev |
| **Admin** | admin, is_admin, role, privilege, internal |
| **Output** | format, output, export, download, raw, json |
| **Control** | limit, offset, page, per_page, count, max |
| **Redirect** | redirect, return_url, next, callback, goto |
| **Auth** | token, api_key, secret, session, auth |
| **Feature** | beta, preview, new, v2, feature, flag |

### Parameter Fuzzing

**Using FFuF:**

```bash
# GET parameter name discovery
ffuf -u "http://target.com/api/user?FUZZ=value" -w params.txt \
     -mc all -fc 404 -fs <baseline_size>

# GET parameter value fuzzing
ffuf -u "http://target.com/api/user?debug=FUZZ" -w values.txt \
     -mc all -fc 404

# POST parameter discovery
ffuf -u "http://target.com/api/user" -X POST \
     -d "FUZZ=value" -w params.txt \
     -H "Content-Type: application/x-www-form-urlencoded"

# JSON parameter discovery
ffuf -u "http://target.com/api/user" -X POST \
     -d '{"known":"value","FUZZ":"test"}' -w params.txt \
     -H "Content-Type: application/json"

# Header fuzzing
ffuf -u "http://target.com/api/user" -H "FUZZ: value" -w headers.txt
```

**Using Arjun:**

```bash
# Automatic parameter discovery
arjun -u http://target.com/page.php

# With wordlist
arjun -u http://target.com/page.php -w params.txt

# POST request
arjun -u http://target.com/page.php -m POST

# JSON mode
arjun -u http://target.com/api -m JSON

# Output to file
arjun -u http://target.com/page -o params.json
```

**Burp Suite Param Miner:**

```
PARAM MINER WORKFLOW:

1. Install extension from BApp Store
2. Right-click request → "Guess parameters"
3. Review findings in Extension output
4. Test discovered parameters manually

PARAM MINER FEATURES:
- Finds reflected parameters
- Detects hidden form fields
- Identifies headers that influence response
- Works with request/response analysis
```

### Identifying Valid Parameters

**Response analysis:**

```
RESPONSE DIFFING:

Baseline request:
GET /page.php HTTP/1.1
Response: 200 OK, Size: 5000 bytes

With guessed parameter:
GET /page.php?test=1 HTTP/1.1
Response: 200 OK, Size: 5000 bytes  ← Same = Invalid parameter

GET /page.php?debug=1 HTTP/1.1
Response: 200 OK, Size: 8500 bytes  ← Different = Valid parameter!

WHAT TO COMPARE:
- Response size
- Response time
- HTTP status code
- Headers
- Content differences
```

### Mass Assignment Vulnerabilities

**Exploiting hidden parameters in APIs:**

```json
// Normal request
POST /api/user
{
  "username": "john",
  "email": "john@test.com"
}

// Mass assignment attack - adding hidden field
POST /api/user
{
  "username": "john",
  "email": "john@test.com",
  "is_admin": true,          // Hidden parameter!
  "role": "admin",           // Another guess
  "verified": true           // Email verification bypass?
}

// If application doesn't whitelist fields:
// User created with admin privileges
```

**Common mass assignment targets:**

```
MASS ASSIGNMENT PATTERNS:

User objects:
- role, is_admin, admin, privilege_level
- verified, email_verified, confirmed
- balance, credits, points
- subscription_tier, plan

Account settings:
- two_factor_enabled → false
- notifications_enabled
- api_key_regenerate

Access control:
- organization_id (access other org's data)
- team_id
- owner_id
```

### Parameter Pollution

**Exploiting multiple parameter handling:**

```
PARAMETER POLLUTION:

Request: /page?id=1&id=2

How do different backends handle this?

Technology     | Result
─────────────────────────────────
PHP            | id = "2" (last)
JSP            | id = "1" (first)
Python/Django  | id = "1" (first)
Node.js        | id = ["1","2"] (array)
ASP.NET        | id = "1,2" (concatenated)

ATTACK SCENARIO:
/transfer?to=attacker&amount=100&to=victim

If WAF blocks based on first 'to' but app uses last 'to':
- WAF sees: to=attacker (blocks? or allows?)
- App uses: to=victim (wrong recipient)
```

### Hidden Admin Functionality

**Common patterns:**

```
ADMIN PARAMETER DISCOVERY:

/api/users?admin=true
/api/users?internal=1
/dashboard?debug=true
/page?source=1
/api/data?export=true&format=csv
/search?verbose=1

HEADER-BASED:
X-Admin: true
X-Debug: 1
X-Internal-Request: 1
X-Original-URL: /admin
```

---

## 3. Guided Practice

### Exercise 1: Parameter Fuzzing Command

Write ffuf commands for:

1. Discover GET parameters:
   ```bash
   ffuf -u "http://target.com/api/___" -w params.txt
   ```

2. Fuzz POST JSON parameters:
   ```bash
   ffuf -u "http://target.com/api/user" ___ -d '___' -w params.txt
   ```

### Exercise 2: Mass Assignment

Given this user registration object:
```json
{
  "username": "test",
  "password": "test123"
}
```

What additional parameters would you try to inject?

1. ___
2. ___
3. ___
4. ___

### Exercise 3: Response Analysis

You're fuzzing parameters. Baseline response is 4500 bytes.

| Parameter | Response Size | Action |
|-----------|---------------|--------|
| debug=1 | 4500 bytes | ___ |
| admin=true | 6200 bytes | ___ |
| format=json | 4500 bytes | ___ |
| verbose=1 | 5100 bytes | ___ |

---

## 4. Reflection Check

### Discovery Understanding
1. A parameter is accepted (no error) but response doesn't change. Is it valid?

2. You found `?debug=1` works. What other related parameters might exist?

3. How would you discover hidden fields in a JSON API without documentation?

### Practical Thinking
1. The API uses dynamic field assignment (no whitelist). Immediate risk?

2. You can add any field to a POST request. How do you find what fields have impact?

3. WAF blocks `admin=true`. What variations might work?

---

## 5. Key Misconceptions

**MYTH: "Undocumented parameters are secure"**
REALITY: Security through obscurity fails. Attackers systematically discover hidden parameters.

**MYTH: "Frontend validation prevents parameter injection"**
REALITY: Attackers bypass frontend entirely. Server must validate all parameters.

**MYTH: "JSON APIs are safe from parameter injection"**
REALITY: Mass assignment is common in JSON APIs. Whitelisting is required.

**MYTH: "Only GET parameters matter"**
REALITY: Parameters exist in POST body, headers, cookies, and path. All are attack surface.

**MYTH: "If it's not in the form, users can't submit it"**
REALITY: Any parameter can be added to any request. Forms don't limit API capabilities.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Identify** parameter contexts across request types
2. **Use** ffuf/Arjun for parameter discovery
3. **Analyze** response differences to find valid parameters
4. **Exploit** mass assignment vulnerabilities conceptually
5. **Apply** parameter pollution techniques

---

## 7. Further Depth (Optional)

*   **Tool:** Master Arjun for automated discovery
*   **Practice:** PortSwigger parameter pollution labs
*   **Research:** Framework-specific mass assignment vulnerabilities
*   **Wordlist:** Build custom parameter lists from target analysis
