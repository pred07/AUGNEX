# Kubernetes Security Engineering

## 1. Tactical Orientation

### Scope of Operations
Kubernetes (K8s) is the operating system of the cloud. Just as Windows/Linux need hardening, K8s requires "Security Engineering" to be safe. It is **insecure by default**. This module teaches you how to lock down the cluster, the network, and the workload.

### Operational Objectives
By the end of this rotation, you will be able to:
*   **Architect Defense:** Apply the 4Cs model (Cloud, Cluster, Container, Code).
*   **Enforce Isolation:** Implement Network Policies to stop lateral movement.
*   **Restrict Workloads:** Use Pod Security Admission (PSA) to ban root containers.
*   **Control Access:** Design Least Privilege RBAC (Role-Based Access Control) models.

---

## 2. Engineering Theory

### The "4Cs" of Cloud Native Security
Security must exist at every layer. If one fails, the next must catch it.
1.  **Cloud:** The underlying infrastructure (AWS/Azure/GCP). Hardened via IAM and VPCs.
2.  **Cluster:** The K8s API Server, Etcd, and Nodes. Hardened via CIS Benchmarks and RBAC.
3.  **Container:** The image runtime. Hardened via distroless images and scanning.
4.  **Code:** The application logic. Hardened via SAST/DAST.

### Pod Security Standards (PSS) & Admission
By default, a Pod can run as `root`, mount host filesystems, and access the raw network. This is a disaster waiting to happen.
**Levels of Hardening:**
*   **Privileged:** Unrestricted (Admin tools only).
*   **Baseline:** Minimally restrictive (Common apps).
*   **Restricted:** Heavily hardened (No root, No capabilities).

**Enforcement:** We use **Pod Security Admission (PSA)** or OPA Gatekeeper to *reject* any Pod that violates the "Restricted" profile.

### Network Policies: Firewalling the Cluster
K8s is a "flat network" by default. Any pod can talk to any other pod.
**Engineering Pattern:** The "Default Deny" Policy.
*   Block ALL traffic by default.
*   Allowlist ONLY specific flows (Frontend -> Backend on Port 80).
*   *Effect:* If the Frontend is compromised, the attacker cannot scan the database or reach the internal admin dashboard.

---

## 3. Technical Implementation

### Hardening a Workload Manifest
A "Security Conscious" deployment manifest.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hardened-app
spec:
  template:
    spec:
      securityContext:
        runAsUser: 1000        # 1. Never run as Root
        runAsGroup: 3000
        fsGroup: 2000
      containers:
      - name: app
        image: myapp:1.2.0
        securityContext:
          allowPrivilegeEscalation: false  # 2. Prevent setuid binaries
          readOnlyRootFilesystem: true     # 3. Immutable filesystem (prevents malware persistence)
          capabilities:
            drop: ["ALL"]                  # 4. Drop Linux Capabilities (Ping, Net_Bind, etc)
```

### The "Default Deny" Network Policy
Apply this to every namespace immediately upon creation.

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
```
*Result:* Silence. Nothing moves until you explicitly allow it.

---

## 4. Operational Lab: Breaking & Fixing RBAC

### Scenario
A developer asks for "Admin" access to debug a pod. You must explain why this is dangerous and engineer a safer solution.

### Directives

#### Step 1: Analyze the Request
*   **Request:** "I need `cluster-admin` to check logs."
*   **Risk:** `cluster-admin` allows deleting nodes, reading secrets, and destroying the cluster.
*   **Engineering Principle:** Least Privilege.

#### Step 2: Design the Role
Create a Role that *only* allows reading logs and pods, restricted to a specific namespace.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: backend-dev
  name: log-reader
rules:
- apiGroups: [""]
  resources: ["pods", "pods/log"]
  verbs: ["get", "list", "watch"]
```

#### Step 3: Bind the Identity
Bind this role to the developer's group. Do **NOT** use `ClusterRoleBinding` (which applies globally). Use `RoleBinding` (namespace scoped).

---

## 5. Debrief & Analysis

### Critical Thinking
1.  **Why is `readOnlyRootFilesystem: true` a powerful anti-malware control?**
    *   *Answer:* Most malware attempts to download a payload (dropper) or modify configuration files. If the filesystem is read-only, `wget malicious.sh` fails. The attacker cannot write to disk.

2.  **What is the difference between a Role and a ClusterRole?**
    *   *Answer:* A **Role** is namespaced (e.g., "Admin of the Finance App"). A **ClusterRole** is global (e.g., "Admin of the entire Cluster"). Mistakes here are the #1 cause of privilege escalation.

3.  **Why do we drop capabilities like `NET_RAW`?**
    *   *Answer:* `NET_RAW` allows packet crafting. If an attacker compromises a pod with this capability, they can perform ARP spoofing or DNS poisoning attacks against other pods in the cluster.
