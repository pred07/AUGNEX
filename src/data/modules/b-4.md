# Design Principles (Least Privilege, Defense in Depth)

## 1. Orientation

### What this module covers
This module dives deep into the "First Principles" of security engineering. Saltzer and Schroeder's 1975 principles are still the bedrock of modern secure design. We will focus on **Least Privilege**, **Defense in Depth**, and **Fail Safe Defaults**.

### Learning Objectives
By the end of this module, you will:
*   Audit a system design against the Principle of Least Privilege (PoLP)
*   Design "choke points" and multiple defensive layers
*   Understand why "Economy of Mechanism" (Simplicity) often beats complex security
*   Apply "Psychological Acceptability" (UX) to security controls

---

## 2. Core Content

### 1. Principle of Least Privilege (PoLP)
**Concept:** A subject should be given only those privileges needed for it to complete its task.
*   **In Practice:**
    *   A web app DB user should only have `SELECT/INSERT/UPDATE`, never `DROP TABLE`.
    *   A lambda function should only access its specific S3 bucket, not `S3:*`.
*   **Hard Mode:** *Just-in-Time (JIT) Privilege*. Permissions don't exist permanently; they are granted for 5 minutes when needed.

### 2. Defense in Depth (Redundancy)
**Concept:** One control will fail. Ensure a second independent control exists.
*   **The Onion Model:**
    *   *Outer:* WAF / DDoS Protection.
    *   *Perimeter:* VPC / Firewall.
    *   *Internal:* Micro-segmentation / Service Mesh.
    *   *Host:* OS Hardening.
    *   *App:* Input Validation / AuthZ.
    *   *Data:* Encryption.

### 3. Fail-Safe Defaults
**Concept:** If the mechanism breaks, it should lock the door, not open it.
*   **Code Example:**
    ```javascript
    // BAD (Fail Open)
    if (user.isAdmin) { ... }
    // What if user is null? Or isAdmin is undefined? Logic might slide through.

    // GOOD (Fail Closed)
    if (!checkPermission(user)) {
       throw new ForbiddenError();
    }
    // Explicit allow logic only.
    ```

### 4. Economy of Mechanism
**Concept:** Keep it simple.
*   Complex security code has bugs.
*   "Attacks always get better; they never get worse." - NSA Limit complexity to limit attack surface.

---

## 3. Case Study: The "Capital One" Breach (SSRF)

### Analysis
An attacker exploited a WAF misconfiguration to access the underlying EC2 instance.
*   **Failure of Defense in Depth:** Once past the WAF, the internal network was flat?
*   **Failure of Least Privilege:** The EC2 Instance Metadata Service (IMDS) had a role attached that allowed listing *all S3 buckets* in the account.
*   **Engineering Fix:**
    1.  Require IMDSv2 (Session token required).
    2.  Scope the IAM Role: Only allow access to the specific bucket needed for that app.

---

## 4. Reflection
1.  Why is "Security through Obscurity" not a valid principle?
2.  How does "Least Privilege" impact "Developer Velocity"? (It slows it downâ€”how do we fix that? Automation.)

---

## 5. Completion Criteria
1.  **Refactor** an IAM policy from `Action: "*"` to specific actions.
2.  **Design** a 3-layer defense for a database (Network, Auth, Encryption).
