# Cryptography Engineering Basics

## 1. Orientation

### What this module covers
This module is not about *math*; it's about *engineering*. You will not learn to write crypto (never write your own crypto). You will learn how to **select, implement, and manage** standard cryptographic primitives correctly. 99% of crypto failures are implementation errors, not broken math.

### Learning Objectives
By the end of this module, you will:
*   Select the correct primitive: AES-GCM vs AES-CBC, SHA-256 vs Argon2 vs bcrypt
*   Understand "Nonce Reuse" failure modes
*   Differentiate between Encryption (Confidentiality), Hashing (Integrity), and Signing (Authenticity)
*   Implement "Hybrid Encryption" (Public Key + Symmetric Key)

---

## 2. Core Content

### Rule #1: Don't Roll Your Own
Use high-level libraries (LibSodium, Tink, WebCrypto API). Do not touch OpenSSL directly if you can avoid it.

### Primitives for Engineers

#### 1. Data at Rest (Symmetric Encryption)
*   **Standard:** AES-256-GCM (Galois Counter Mode).
*   **Why GCM?** It provides **Authenticated Encryption**. It encrypts data (confidentiality) AND ensures it hasn't been tamperered with (integrity).
*   **Pitfall:** AES-ECB. It leaks patterns (the "Tux Penguin" image). NEVER use ECB.

#### 2. Passwords (Hashing)
*   **Standard:** Argon2id (Best), scrypt, bcrypt.
*   **Avoid:** MD5, SHA-1, SHA-256 (Too fast! GPUs can guess billions per second).
*   **Concept:** "Salting" prevents Rainbow Tables. "Work Factor" slows down brute force.

#### 3. Data in Transit (Transport)
*   **Standard:** TLS 1.3.
*   **Cipher Suites:** Prefer Forward Secrecy (ECDHE).
*   **Avoid:** SSLv3, TLS 1.0, RC4 ciphers.

#### 4. Digital Signatures
*   **Standard:** Ed25519 (Modern, safe curves) or RSA-4096.
*   **Use Case:** verifying JWTs, software updates, or git commits.

### Randomness (Entropy)
*   **CSPRNG:** Cryptographically Secure Pseudo-Random Number Generator.
*   **Code:**
    *   `Random()` = BAD (Predictable).
    *   `crypto.getRandomValues()` / `secrets.token_bytes()` = GOOD.

---

## 3. Guided Lab: Breaking Bad Crypto

### Scenario
You are auditing a legacy Node.js app.

### Code Snippet A:
```javascript
const crypto = require('crypto');
function encrypt(text) {
  const cipher = crypto.createCipher('aes-192-cbc', 'my_password'); // ‚ùå
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}
```
**Issues:**
1.  `createCipher` (deprecated) uses a weak key derivation (MD5). Use `createCipheriv`.
2.  Key is a string literal (low entropy).
3.  IV (Initialization Vector) is missing/static. **Static IV = Broken Crypto.**
4.  CBC mode without HMAC allows "Padding Oracle Attacks".

### Code Snippet B (Fixed):
```javascript
const crypto = require('crypto');
const algorithm = 'aes-256-gcm'; 
const key = crypto.randomBytes(32); // Random 256-bit key
const iv = crypto.randomBytes(12); // Random IV

function encrypt(text) {
  const cipher = crypto.createCipheriv(algorithm, key, iv);
  // ... encrypt ...
  const tag = cipher.getAuthTag(); // Integrity check!
  return { content: encrypted, iv: iv, tag: tag };
}
```

---

## 4. Reflection Check
1.  Why is SHA-256 good for file checksums but bad for passwords?
2.  What happens if you use the same Nonce/IV twice with a stream cipher (like AES-GCM or ChaCha20)? (Answer: The key stream is exposed, allowing XOR decryption.)

---

## 5. Completion Criteria
1.  **Identify** unsafe patterns like `AES-ECB` or `MD5`.
2.  **Explain** why Authenticated Encryption (AEAD) is mandatory for web apps.
3.  **Choose** the right algorithm for a given use case.
