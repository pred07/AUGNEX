# Input Validation and Injection Fundamentals

## 1. Unit Brief: Trust Issues
All injection attacks (SQLi, XSS, Command Injection) stem from a single root cause: **Untrusted Input**. The application takes what you typed and treats it as code instead of data.

## 2. Real-World Relevance
*   **Data**: "Hello World".
*   **Code**: `SELECT * FROM users`.
*   **Injection**: `Hello'; DROP TABLE users;--`
If the application pastes your "Data" directly into its "Code" sentence without checking it, you have changed the meaning of the command.

## 3. Core Concepts

### The Interpreter
Every app talks to interpreters (SQL database, LDAP, Shell, Browser).
Injection happens when your input "breaks out" of the data context and commands the interpreter directly.

### Sanitization (Blacklisting) implies Failure
Trying to remove "bad characters" (like `'` or `<`) usually fails. Hackers find ways around it (e.g., URL encoding, double encoding).

### Validation (Whitelisting)
The robust defense. "I expect an integer. If you send text, I reject it."

## 4. Practical Examples

### The Concept of "Breakout"
Imagine a command: `print("Hello " + name)`
*   Input: `Bob` -> `print("Hello Bob")` (Safe)
*   Input: `Bob"); system("shutdown");`
*   Result: `print("Hello Bob"); system("shutdown");`
You closed the first command and started a new one.

### Context Matters
*   **SQL Context**: You need `'` to break out.
*   **HTML Context**: You need `<` or `"` to break out.
*   **Shell Context**: You need `;` or `|` to break out.

## 5. Common Mistakes Beginners Make
*   **Throwing random payloads**: Copy-pasting complex polyglots without understanding *where* the data is going.
*   **Thinking WAFs are invincible**: A Web Application Firewall blocks common patterns, but it doesn't fix the underlying code flaw.

## 6. Key Takeaways
*   **Input is Enemy**: Never trust it.
*   **Injection is Syntax**: You are tricking the parser into reading your data as instructions.
