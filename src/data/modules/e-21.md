# Input Validation and Injection Fundamentals

## 1. Orientation

### What this module covers
This module covers the root cause of most web vulnerabilities: trusting user input. Understanding the fundamental concept of injection—when data becomes code—provides the foundation for understanding SQLi, XSS, command injection, LDAP injection, and more.

### Fit in the Learning Path
If you understand WHY injection happens (mixing code and data), you can recognize it in any context—SQL, HTML, OS commands, LDAP, XML, and emerging technologies. This conceptual foundation is essential before studying specific injection types.

### Learning Objectives
By the end of this module, you will:
*   Understand the code/data separation principle
*   Recognize injection vulnerability patterns
*   Differentiate validation strategies (whitelist, blacklist, parameterization)
*   Identify bypass techniques for common defenses

---

## 2. Core Content

### Mental Model: When Data Becomes Code

**How professionals think about this:**
Computers execute instructions (code) on values (data). Injection happens when a system cannot distinguish where code ends and data begins—allowing attacker-controlled data to be executed as code.

```
THE INJECTION PRINCIPLE:

NORMAL OPERATION:
┌────────────────────────────────────────────────────┐
│ CODE                  DATA                CODE    │
│  │                     │                   │      │
│  ▼                     ▼                   ▼      │
│ SELECT * FROM users WHERE name = 'Alice'         │
│ └──────────────────────┘       └───┘             │
│         Fixed code              User              │
│                                 input             │
│                                                   │
│ RESULT: Query for user "Alice"                   │
└────────────────────────────────────────────────────┘

INJECTION:
┌────────────────────────────────────────────────────┐
│ CODE                  DATA → CODE                 │
│  │                     │                          │
│  ▼                     ▼                          │
│ SELECT * FROM users WHERE name = 'Alice'; DROP TABLE users;--'
│                               └───────────────────────────────┘
│                                    User input, but interpreted
│                                    as code!
│                                                   │
│ RESULT: Data retrieved AND table dropped          │
└────────────────────────────────────────────────────┘

KEY INSIGHT: The ' character broke out of data context
             The ; started new code
             The -- commented out remaining code
```

### Injection Contexts

**Where injection occurs:**

| Context | Code Language | Data Becomes | Example |
|---------|---------------|--------------|---------|
| **Database** | SQL | SQL commands | SQLi |
| **Browser** | HTML/JS | JavaScript/HTML | XSS |
| **Operating System** | Shell | OS commands | Command Injection |
| **XML Parser** | XML | External entities | XXE |
| **LDAP Server** | LDAP | LDAP queries | LDAP Injection |
| **Email** | SMTP | Email headers | Header Injection |
| **Template** | Template lang | Template code | SSTI |
| **File Path** | File system | Path components | Path Traversal |

**Context escaping:**

```
CONTEXT ESCAPING CONCEPT:

SQL Context:
' closes a string → allows code injection

HTML Context:
< opens a tag → allows HTML/JS injection

Shell Context:
; separates commands → allows command injection

LDAP Context:
) closes a filter → allows filter injection

Each context has ESCAPE CHARACTERS that break
the data/code boundary
```

### Defense Strategies

**Validation approaches compared:**

```
DEFENSE STRATEGIES:

1. BLACKLISTING (Weak)
   ───────────────────
   "Block dangerous characters: ' " ; < >"
   
   PROBLEM: Bypass examples:
   - Encoding: %27 instead of '
   - Case: SELECT vs SeLeCt
   - Alternate syntax: `char()` instead of literal
   - New attack vectors not in blacklist
   
   WHY IT FAILS:
   You're defending against what you KNOW
   Attackers use what you DON'T KNOW

2. WHITELISTING (Better)
   ───────────────────
   "Only allow: a-z, A-Z, 0-9"
   
   ADVANTAGE:
   - Unexpected input rejected
   - New attack vectors automatically blocked
   
   LIMITATION:
   - Can't always predict valid input
   - International characters?
   - Complex data formats?

3. ENCODING/ESCAPING (Context-specific)
   ───────────────────
   Convert dangerous characters to safe equivalents
   
   SQL:  ' → ''
   HTML: < → &lt;
   URL:  ' → %27
   
   LIMITATION:
   - Must match the correct context
   - Easy to get wrong
   - Layered contexts complicate

4. PARAMETERIZATION (Best for queries)
   ───────────────────
   Separate code and data channels completely
   
   CODE: "SELECT * FROM users WHERE name = ?"
   DATA: ["Alice"]
   
   The database KNOWS the input is data
   Even malicious input stays as data
   
   ADVANTAGE:
   - No escaping needed
   - No bypass possible (for query injection)
   - Language provides the mechanism
```

### Bypass Techniques

**Why blacklists fail:**

```
BLACKLIST BYPASS EXAMPLES:

Original: <script>alert(1)</script>
Blocked:  SCRIPT tag detected

Bypass 1 (Case): <ScRiPt>alert(1)</ScRiPt>
Bypass 2 (HTML encode): <script>alert&#40;1&#41;</script>
Bypass 3 (Event handler): <img src=x onerror=alert(1)>
Bypass 4 (Nesting): <scr<script>ipt>alert(1)</scr</script>ipt>
Bypass 5 (Unicode): <script>alert(1)</script>

Original: ' OR 1=1--
Blocked:  OR detected

Bypass 1 (Case): ' oR 1=1--
Bypass 2 (Comment): '/**/OR/**/1=1--
Bypass 3 (Encoding): %27%20OR%201=1--
Bypass 4 (Function): ' || 1=1--
Bypass 5 (Numeric): ' OR 2>1--

THE PATTERN:
Blacklists block KNOWN attacks
Attackers create UNKNOWN variants
```

### Input Handling Principles

**Secure input processing:**

```
INPUT HANDLING RULES:

1. NEVER TRUST USER INPUT
   - All input is potentially malicious
   - "User input" includes: forms, URLs, headers, cookies, 
     files, APIs, database data, partner feeds

2. VALIDATE EARLY, REJECT FIRMLY
   - Check input at entry point
   - Reject invalid input (don't try to "fix" it)
   - Return clear error (without revealing internals)

3. USE POSITIVE VALIDATION
   - Define what IS valid
   - Reject everything else
   - Example: "Must be 8-32 alphanumeric" not "Must not contain <>"

4. ENCODE FOR OUTPUT CONTEXT
   - Same data may go to HTML, JavaScript, SQL
   - Encode appropriately for each context
   - HTML entity encoding for HTML
   - JavaScript escaping for JS strings
   - SQL parameters for queries

5. DEFENSE IN DEPTH
   - Validation AND encoding AND parameterization
   - WAF as additional layer (not primary defense)
   - Assume each layer might fail
```

### Client vs Server Validation

**Why client-side is insufficient:**

```
CLIENT-SIDE VALIDATION:

User → Browser (JavaScript validates) → Server

BYPASS OPTIONS:
1. Disable JavaScript
2. Use browser developer tools
3. Use proxy (Burp Suite)
4. Use curl/scripts directly
5. Modify browser requests

DEMONSTRATION:
<input type="text" maxlength="10" pattern="[a-z]+">
<script>
if (input.length > 10) { alert("Too long!"); return; }
</script>

ATTACKER:
curl -X POST -d "input=AAAAAAA'; DROP TABLE users;--" target.com
(JavaScript never runs)

CONCLUSION:
Client-side validation = UX improvement
Server-side validation = Security requirement
```

### Injection Polyglots

**Testing multiple contexts:**

```
POLYGLOT PAYLOADS:

Purpose: Single payload that tests multiple injection types

Example:
'"`<script>alert(1)</script>{{7*7}}${7*7}

Tests for:
- SQL injection (')
- SQL injection (")
- HTML injection (<)
- XSS (<script>)
- Template injection ({{7*7}})
- Expression language (${7*7})

If response shows:
- SQL error → SQLi
- "alert(1)" executed → XSS
- "49" in output → Template injection

USAGE:
Quick initial testing of unknown input fields
```

### Context-Specific Encoding

**Match encoding to output:**

```
ENCODING BY CONTEXT:

Data: O'Reilly

Going to SQL context:
"... name = 'O''Reilly' ..."  (escape single quote)

Going to HTML context:
"<p>Hello O&#39;Reilly</p>"   (HTML entity)

Going to JavaScript context:
"var name = 'O\'Reilly';"     (JS escape)

Going to URL context:
"?name=O%27Reilly"            (URL encode)

DANGER: Using wrong encoding for context
- HTML encoding in SQL = SQLi still works
- SQL escaping in HTML = XSS still works
```

---

## 3. Guided Practice

### Exercise 1: Injection Pattern Recognition

For each scenario, identify:
1. The data context
2. The escape character(s)
3. Example injection payload

| Scenario | Context | Escape | Payload |
|----------|---------|--------|---------|
| `echo "Hello $input"` (shell) | ___ | ___ | ___ |
| `<p>Welcome ${input}</p>` (template) | ___ | ___ | ___ |
| `ldap_search("(cn=$input)")` | ___ | ___ | ___ |

### Exercise 2: Blacklist Bypass

The application blocks these characters: `' " -- < >`

Write bypasses for:

1. SQL injection: ___
2. XSS: ___

### Exercise 3: Validation Strategy

For a username field (8-20 chars, alphanumeric only):

1. Write a whitelist validation regex: ___
2. Write what a blacklist might look like (and why it's worse): ___

---

## 4. Reflection Check

### Understanding Injection
1. Why does parameterization prevent SQL injection but not XSS?

2. A developer says "I escape all quotes." Is this sufficient? Why or why not?

3. You input `{{7*7}}` and see `49` in the response. What vulnerability exists?

### Defense Understanding
1. Input is validated client-side in JavaScript. Is server-side validation still needed?

2. The application encodes `<` as `&lt;` before database storage. Is SQL injection prevented?

3. Why might encoding/escaping fail in complex applications?

---

## 5. Key Misconceptions

**MYTH: "Client-side validation is security"**
REALITY: Client-side improves UX. Attackers bypass it trivially. Server-side is required.

**MYTH: "We block dangerous characters, so we're safe"**
REALITY: Blacklists always have bypasses. Encoding, alternate syntax, and new techniques exist.

**MYTH: "Input validation is the solution"**
REALITY: Validation reduces surface but isn't enough. Output encoding and parameterization are essential.

**MYTH: "Escaping solves injection"**
REALITY: Escaping must match context exactly. Multi-context data requires multiple encodings.

**MYTH: "Modern frameworks prevent injection"**
REALITY: Frameworks provide tools, but misuse (like raw queries) still causes vulnerabilities.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Explain** the code/data confusion that causes injection
2. **Identify** injection contexts and escape characters
3. **Compare** validation strategies (blacklist vs whitelist vs parameterization)
4. **Demonstrate** blacklist bypass techniques
5. **Apply** context-appropriate encoding

---

## 7. Further Depth (Optional)

*   **Practice:** OWASP WebGoat input validation lessons
*   **Research:** OWASP Input Validation Cheat Sheet
*   **Lab:** Build vulnerable app and practice bypasses
*   **Advanced:** Study polyglot payloads and fuzzing techniques
