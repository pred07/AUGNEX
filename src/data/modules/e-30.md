# API Security Testing Fundamentals

## 1. Orientation

### What this module covers
This module covers API security testing—the techniques and vulnerabilities specific to REST, GraphQL, and modern web services. As applications increasingly rely on APIs, understanding API security is essential.

### Fit in the Learning Path
Traditional web security focused on HTML forms and browsers. Modern applications are API-first—mobile apps, SPAs, and microservices all communicate via APIs. Different attack surface requires different techniques.

### Learning Objectives
By the end of this module, you will:
*   Understand OWASP API Top 10
*   Test REST and GraphQL APIs
*   Identify API-specific vulnerabilities
*   Use API testing tools effectively

---

## 2. Core Content

### Mental Model: The Raw Interface

**How professionals think about this:**
APIs expose the raw application logic without UI constraints. What the frontend hides, the API returns. What the UI restricts, the API may allow. APIs are the honest truth about what an application can do.

```
API vs TRADITIONAL WEB:

TRADITIONAL WEB (Browser-based):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  Browser ──► Website ──► Backend                                   │
│                                                                     │
│  - HTML forms constrain input                                      │
│  - UI hides internal data                                          │
│  - JavaScript validates client-side                                │
│  - Heavy server-side rendering                                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

MODERN API (Direct access):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  App/Script ──► API ──► Backend                                   │
│                                                                     │
│  - JSON payloads, no UI constraints                                │
│  - Full object returned (frontend filters display)                 │
│  - Direct method calls (GET, POST, PUT, DELETE, PATCH)            │
│  - Documentation tells you everything                              │
│                                                                     │
│  ATTACKER VIEW:                                                    │
│  No UI = No UI-enforced restrictions                               │
│  Full object = More data exposed                                   │
│  Direct access = More attack surface                               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### OWASP API Top 10

**API-specific vulnerabilities:**

```
OWASP API TOP 10 (2023):

1. API1: BROKEN OBJECT LEVEL AUTHORIZATION (BOLA)
   ─────────────────────────────
   IDOR for APIs
   GET /api/users/123/profile ← Your ID
   GET /api/users/124/profile ← Other user's ID
   
   No authorization check on object access

2. API2: BROKEN AUTHENTICATION
   ─────────────────────────────
   Weak tokens, no token expiration
   JWT vulnerabilities
   No rate limiting on login

3. API3: BROKEN OBJECT PROPERTY LEVEL AUTHORIZATION
   ─────────────────────────────
   Excessive data exposure
   Mass assignment
   Return more fields than needed

4. API4: UNRESTRICTED RESOURCE CONSUMPTION
   ─────────────────────────────
   No rate limiting
   No pagination limits
   DoS via expensive queries

5. API5: BROKEN FUNCTION LEVEL AUTHORIZATION (BFLA)
   ─────────────────────────────
   Access admin functions as regular user
   POST /api/admin/users as normal user

6. API6: UNRESTRICTED ACCESS TO SENSITIVE BUSINESS FLOWS
   ─────────────────────────────
   Automating attacks (ticket scalping, account creation)
   Business logic abuse at scale

7. API7: SERVER-SIDE REQUEST FORGERY (SSRF)
   ─────────────────────────────
   API fetches URLs provided by user
   Access internal services

8. API8: SECURITY MISCONFIGURATION
   ─────────────────────────────
   CORS too permissive
   Debug endpoints exposed
   Default credentials

9. API9: IMPROPER INVENTORY MANAGEMENT
   ─────────────────────────────
   Old API versions still accessible
   Shadow APIs (undocumented endpoints)
   Development endpoints in production

10. API10: UNSAFE CONSUMPTION OF APIS
    ─────────────────────────────
    Trusting third-party APIs
    Not validating external responses
```

### BOLA (Broken Object Level Authorization)

**The most common API vulnerability:**

```
BOLA ATTACKS:

CONCEPT:
─────────────────────────────
User A should only access User A's data
API doesn't verify ownership before returning data

EXAMPLES:

GET /api/orders/1001  ← Your order
GET /api/orders/1002  ← Someone else's order (BOLA!)

GET /api/accounts/abc123/balance  ← Your account
GET /api/accounts/xyz789/balance  ← Other account (BOLA!)

POST /api/users/456/password  ← Change other's password

TESTING METHODOLOGY:
─────────────────────────────
1. Capture request for your resource
2. Identify the ID/reference
3. Change to another ID:
   - Sequential (1001 → 1002)
   - Predictable (user123 → user124)
   - UUID (try from other session)
4. Check if data returned

DETECTION:
─────────────────────────────
Look for IDs in:
- URL path: /api/users/{id}
- Query params: ?orderId=123
- Request body: {"userId": 123}
- Headers: X-User-Id: 123

Response with different user's data = BOLA confirmed
```

### Mass Assignment

**Object property manipulation:**

```
MASS ASSIGNMENT:

CONCEPT:
─────────────────────────────
API accepts JSON and binds directly to object
Attacker includes fields they shouldn't control

VULNERABLE CODE:
─────────────────────────────
user.update(request.body)
// Accepts any field from request

INTENDED REQUEST:
{
  "name": "John",
  "email": "john@example.com"
}

ATTACK REQUEST:
{
  "name": "John",
  "email": "john@example.com",
  "role": "admin",           ← Added!
  "credit": 10000,           ← Added!
  "verified": true           ← Added!
}

TESTING:
─────────────────────────────
1. Capture update request (PUT/POST)
2. Get the full object (GET)
3. Note all fields in response
4. Add those fields to update request
5. Include sensitive fields: role, permissions, credit
6. Check if changes applied
```

### GraphQL Security

**Testing GraphQL APIs:**

```
GRAPHQL ATTACKS:

1. INTROSPECTION
   ─────────────────────────────
   Query the schema itself
   
   {__schema{types{name,fields{name,type{name}}}}}
   
   Returns entire API structure
   Find hidden fields, admin queries
   
   Defense: Disable in production

2. FIELD SUGGESTIONS
   ─────────────────────────────
   Even without introspection, GraphQL suggests
   
   query { user { pasword }}
   Error: "Did you mean 'password'?"

3. BATCHING ATTACKS
   ─────────────────────────────
   Multiple queries in one request
   
   Brute force login:
   query {
     login1: login(user:"admin",pass:"password1")
     login2: login(user:"admin",pass:"password2")
     login3: login(user:"admin",pass:"password3")
     ...
   }
   
   1000 attempts in 1 request = bypass rate limit

4. NESTED QUERY DoS
   ─────────────────────────────
   Deeply nested queries
   
   {users{friends{friends{friends{friends{...}}}}}}
   
   Exponential resource consumption
   
   Defense: Query depth limits

5. AUTHORIZATION BYPASS
   ─────────────────────────────
   Same BOLA/BFLA issues
   
   query { user(id: 456) { password creditCard }}
   mutation { deleteUser(id: 456) }
```

### API Discovery

**Finding the attack surface:**

```
API DISCOVERY:

1. DOCUMENTATION
   ─────────────────────────────
   /api/docs
   /swagger.json
   /swagger-ui.html
   /api-docs
   /openapi.json
   /graphql/schema
   
   Import into Postman

2. JAVASCRIPT FILES
   ─────────────────────────────
   Parse JS for API endpoints
   
   grep -r "fetch\|axios\|api" app.js
   
   Find: /api/v2/admin/secret-endpoint

3. VERSION DISCOVERY
   ─────────────────────────────
   /api/v1/users (maybe vulnerable)
   /api/v2/users (current)
   /api/v3/users (beta?)
   
   Try old versions for unpatched bugs

4. METHOD ENUMERATION
   ─────────────────────────────
   Endpoint: /api/users
   
   Try: GET, POST, PUT, DELETE, PATCH, OPTIONS
   Each may have different behavior

5. PARAMETER DISCOVERY
   ─────────────────────────────
   /api/users?debug=true
   /api/users?admin=true
   /api/users?_internal=1
   
   Hidden parameters may exist
```

### API Testing Tools

**Essential toolkit:**

```
API TESTING TOOLS:

POSTMAN:
─────────────────────────────
Import Swagger/OpenAPI
Create test collections
Environment variables
Automate test sequences

BURP SUITE:
─────────────────────────────
Capture API traffic
Modify requests
Automated scanning
Intruder for fuzzing

GRAPHQL SPECIFIC:
─────────────────────────────
GraphQL Voyager - Schema visualization
InQL - Burp extension
Altair - GraphQL client

API SCANNERS:
─────────────────────────────
Nuclei (with API templates)
Wfuzz (parameter fuzzing)
Arjun (parameter discovery)
```

---

## 3. Guided Practice

### Exercise 1: BOLA Testing

API endpoint: `GET /api/v1/invoices/INV-001`

1. What variations would you try? ___
2. What response indicates success? ___
3. How do you get valid IDs to test? ___

### Exercise 2: GraphQL Introspection

Run this query on a GraphQL endpoint:

```graphql
{__schema{types{name}}}
```

1. What types are revealed? ___
2. Any sensitive-looking types? ___
3. Next query to run? ___

### Exercise 3: Mass Assignment

User update endpoint returns:
```json
{
  "id": 123,
  "name": "Alice",
  "email": "alice@example.com",
  "role": "user",
  "credits": 100
}
```

What fields would you add to your update request?
___

---

## 4. Reflection Check

### API Understanding
1. Frontend only shows name and email. API returns full object. Issue?

2. /api/v1 deprecated but still works. Why test it?

3. GraphQL introspection disabled. How to discover schema?

### Security Thinking
1. Rate limiting exists on frontend. API called directly?

2. JWT has 24-hour expiration. User access revoked. Problem?

3. API returns `{"success": false}` for unauthorized. Information leaked?

---

## 5. Key Misconceptions

**MYTH: "API security is same as web security"**
REALITY: APIs have different vulnerabilities (BOLA, mass assignment) and require different tools.

**MYTH: "If the frontend doesn't show it, it's hidden"**
REALITY: API returns full objects. Frontend filtering ≠ access control.

**MYTH: "API documentation is only for developers"**
REALITY: Documentation is an attack roadmap. Swagger files are goldmines.

**MYTH: "HTTPS protects the API"**
REALITY: HTTPS protects transport. Authorization, rate limiting, and input validation still needed.

**MYTH: "GraphQL is more secure than REST"**
REALITY: GraphQL has its own vulnerabilities (batching, DoS queries, introspection).

---

## 6. Completion Criteria

This module is complete when you can:

1. **Test** for BOLA vulnerabilities
2. **Identify** mass assignment attack vectors
3. **Query** GraphQL schemas via introspection
4. **Discover** API endpoints and versions
5. **Use** Postman and Burp for API testing

---

## 7. Further Depth (Optional)

*   **Practice:** Hack The Box API challenges
*   **Tool:** Master Postman for API testing
*   **Research:** OWASP API Top 10 in depth
*   **Lab:** Build vulnerable API for practice
