# CPU, Memory, Storage, and Processes

## 1. Orientation

### What this module covers
This module demystifies the resources that your operating system manages. We define what a "Process" actually is and how the CPU executes it.

### Fit in the Learning Path
Malware is just a Process. To hide malware, attackers manipulate Memory and CPU execution. To find it, you must know what "Normal" looks like.

### Learning Objectives
By the end of this module, you should understand:
*   The definition of a **Process** vs a **Program**.
*   How **RAM** works (Stack and Heap).
*   The Fetch-Decode-Execute cycle.

---

## 2. Core Content

### Program vs Process
*   **Program**: A static file on the disk (e.g., `chrome.exe`). Dead bytes.
*   **Process**: That program loaded into RAM and running. It has a Process ID (PID), memory capability, and a user owner.

### Memory Concepts (Simplified)
When a program runs, it gets a slice of RAM.
1.  **Code Segment**: The instructions (ReadOnly).
2.  **Data Segment**: Global variables.
3.  **Heap**: Dynamic memory (e.g., loading a webpage image provided by the user). *Buffer Overflows happen here.*
4.  **Stack**: Temporary function variables. *Stack Overflows happen here.*

### CPU Cycle
The CPU is dumb and fast.
1.  **Fetch**: Get the next instruction from RAM.
2.  **Decode**: Figure out what it means (ADD, SUB, JUMP).
3.  **Execute**: Do it.
*   **Clock Speed**: 3 GHz = 3 Billion cycles per second.

---

## 3. Guided Practice

### Freezing a Process
We will manually send signals to a process to control its execution lifecycle.

**Step 1: Start a Process**
Open a terminal and run `sleep 1000`. (This simply waits for 1000 seconds).

**Step 2: Suspend It**
*   Press `Ctrl + Z`.
*   Output: `[1]+  Stopped`.
*   **Status**: The process exists in RAM, but the Scheduler is ignoring it. It uses 0% CPU.

**Step 3: Background It**
*   Type `bg`.
*   Output: `[1]+ sleep 1000 &`.
*   **Status**: It is running again, but in the background.

**Step 4: Kill It**
*   Type `jobs` (note the ID, usually 1).
*   Type `kill %1`.
*   **Status**: The OS reclaims the memory. The process is dead.

---

## 4. Reflection Check

1.  **Forensics**: If you pull the power plug, what happens to the data in RAM? What happens to the data on Disk?
2.  **Performance**: Why does opening 50 Chrome tabs slow down your computer even if you aren't looking at them? (RAM exhaustion forcing "Swap" to disk).
3.  **Isolation**: Can Process A read the memory of Process B? (Generally No - unless you are the Kernel or a Debugger).

---

## 5. Completion Criteria

This module is complete when:
1.  You can define a "Process" (Active) vs "Program" (Passive).
2.  You have successfully suspended and killed a process using signals.
3.  You understand that RAM is volatile.
