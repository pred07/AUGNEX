# CPU, Memory, Storage, and Processes

## 1. Orientation

### What this module covers
This module explains how the operating system manages computing resources—CPU time, memory, and storage—and how these resources are allocated to running programs (processes). Understanding this is essential: every exploit technique, from buffer overflows to process injection, manipulates these fundamental concepts.

### Fit in the Learning Path
Malware is just a process. Exploits target memory. Persistence uses storage. You cannot understand attacks without understanding what attackers are attacking. This module makes advanced offensive and defensive techniques comprehensible by building the foundation they operate on.

### Learning Objectives
By the end of this module, you will:
*   Distinguish between programs (static) and processes (running)
*   Understand process memory layout and why it matters for exploitation
*   Explain CPU scheduling and process states
*   Apply process management commands for investigation and control

---

## 2. Core Content

### Mental Model: The Resource Manager

**How professionals think about this:**
The operating system is fundamentally a resource manager. It allocates CPU time, memory, and I/O access to competing processes. Security often comes down to whether a process can access resources it shouldn't—other processes' memory, privileged files, or hardware.

```
OPERATING SYSTEM AS RESOURCE MANAGER:

┌─────────────────────────────────────────────────────────────────────┐
│                    KERNEL (Resource Arbitrator)                     │
│                                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                 │
│  │   CPU       │  │   Memory    │  │   I/O       │                 │
│  │ Scheduler   │  │  Manager    │  │  Manager    │                 │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘                 │
└─────────┼────────────────┼────────────────┼─────────────────────────┘
          │                │                │
   ┌──────┴──────┐  ┌──────┴──────┐  ┌──────┴──────┐
   │  Process 1  │  │  Process 2  │  │  Process 3  │
   │ (Firefox)   │  │ (Terminal)  │  │ (Malware?)  │
   │             │  │             │  │             │
   │ CPU time    │  │ Memory      │  │ File access │
   │ allocation  │  │ allocation  │  │ allocation  │
   └─────────────┘  └─────────────┘  └─────────────┘
```

### Program vs Process

**Program:**
- Static file on disk (e.g., `/usr/bin/firefox`, `C:\Windows\notepad.exe`)
- Just bytes—instructions and data not yet executing
- Cannot do anything until loaded and executed

**Process:**
- Program loaded into memory and executing
- Has a Process ID (PID)
- Has allocated memory (address space)
- Has an owner (user context)
- Has state (running, sleeping, stopped)
- Has open file handles, network connections

**Thread:**
- Unit of execution within a process
- Shares process memory
- Has own execution context (registers, stack)
- Multiple threads = parallelism within one process

```
RELATIONSHIP:

     PROGRAM (on disk)            PROCESS (in memory)
     ┌────────────────┐           ┌────────────────────────┐
     │                │           │ PID: 1234              │
     │ /usr/bin/bash  │───RUN───► │ User: kali             │
     │                │           │ Memory: 12 MB          │
     │ (static file)  │           │ State: Running         │
     └────────────────┘           │                        │
                                  │ ┌────────┐ ┌────────┐  │
                                  │ │Thread 1│ │Thread 2│  │
                                  │ └────────┘ └────────┘  │
                                  └────────────────────────┘
```

### Process Memory Layout

When a process runs, the OS allocates virtual memory with distinct regions:

```
HIGH ADDRESS
┌─────────────────────────────────────┐ 0xFFFFFFFF (32-bit)
│             KERNEL SPACE            │ (Not accessible to user process)
├─────────────────────────────────────┤
│                                     │
│              STACK                  │ ◄── Local variables, return addresses
│           (grows down ↓)            │     Stack overflow attacks target here
│                                     │
├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┤
│                                     │
│         (Unmapped space)            │
│                                     │
├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┤
│                                     │
│              HEAP                   │ ◄── Dynamic allocation (malloc)
│           (grows up ↑)              │     Heap overflow attacks target here
│                                     │
├─────────────────────────────────────┤
│         UNINITIALIZED DATA          │ ◄── BSS segment (globals = 0)
│              (BSS)                  │
├─────────────────────────────────────┤
│         INITIALIZED DATA            │ ◄── Data segment (globals with values)
│             (.data)                 │
├─────────────────────────────────────┤
│                                     │
│              TEXT                   │ ◄── Code segment (instructions)
│         (Read + Execute)            │     Usually read-only
│                                     │
└─────────────────────────────────────┘ 0x00000000
LOW ADDRESS
```

**Security implications of each region:**

| Region | Purpose | Attack Relevance |
|--------|---------|------------------|
| **Stack** | Function calls, local vars | Stack buffer overflow, return address overwrite |
| **Heap** | Dynamic allocation | Heap overflow, use-after-free, heap spray |
| **Data/BSS** | Global variables | Data corruption, format string attacks |
| **Text** | Executable code | Code injection (if writable), ROP gadgets |

### CPU Scheduling and Process States

**Process lifecycle:**
```
                    ┌─────────────┐
                    │   CREATED   │
                    └──────┬──────┘
                           │ (Admitted)
                           ▼
    ┌─────────────────────────────────────────────┐
    │                   READY                     │
    │  (Waiting for CPU time)                     │◄────────────┐
    └────────────────────┬────────────────────────┘             │
                         │ (Scheduled)                          │
                         ▼                                      │
    ┌─────────────────────────────────────────────┐             │
    │                  RUNNING                    │             │
    │  (Currently executing on CPU)               │─────────────┘
    └────────────────────┬────────────────────────┘   (Time slice
                         │                              expired)
          ┌──────────────┼──────────────┐
          │              │              │
          ▼              ▼              ▼
    ┌──────────┐   ┌──────────┐   ┌──────────┐
    │ BLOCKED  │   │ STOPPED  │   │TERMINATED│
    │(Waiting  │   │(Signal   │   │(Finished)│
    │ for I/O) │   │ stopped) │   │          │
    └──────────┘   └──────────┘   └──────────┘
          │              │
          └──────────────┘
           (I/O complete, signal resume)
```

**Process states explained:**

| State | Description | Example |
|-------|-------------|---------|
| **Running** | Currently executing | Active computation |
| **Ready** | Can run, waiting for CPU | Scheduled but not current |
| **Blocked/Waiting** | Waiting for something | Reading from disk, network I/O |
| **Stopped** | Suspended (SIGSTOP) | Ctrl+Z in terminal |
| **Zombie** | Terminated, waiting for parent | Exit status not collected |

### CPU Execution

**The Fetch-Decode-Execute cycle:**
```
while (power_on) {
    instruction = fetch(instruction_pointer);  // Get from memory
    operation = decode(instruction);           // Interpret meaning
    execute(operation);                        // Do the work
    instruction_pointer++;                     // Move to next
}
```

**Clock speed context:**
- 3 GHz = 3 billion cycles per second
- Each instruction may take 1-X cycles
- Modern CPUs execute multiple instructions per cycle (superscalar)
- Context switches (changing processes) are expensive (~1000s of cycles)

### Memory Types: Volatility Matters

| Type | Speed | Persistence | Security Implication |
|------|-------|-------------|---------------------|
| **Registers** | Instant | Power-off lost | Volatile, tiny |
| **Cache** | ~1ns | Power-off lost | Side-channel attacks |
| **RAM** | ~100ns | Power-off lost | Memory forensics window |
| **SSD/HDD** | ~1ms | Permanent | Data recovery possible |

**Forensic implications:**
- RAM: Lost on power-off (but can persist briefly—cold boot attack)
- Disk: Data survives deletion (until overwritten)
- Swap: RAM written to disk may persist

### Process Isolation

**The security boundary:**
Processes are isolated from each other:
- Each process has its own virtual address space
- Process A cannot read Process B's memory
- The kernel enforces these boundaries

**Ways isolation is broken:**
- Kernel exploits (gain kernel privileges)
- Debugging interfaces (ptrace, Windows debug APIs)
- Shared memory (intentionally shared)
- Side-channel attacks (cache timing)
- Process injection techniques

**Process injection flow:**
```
Attacker Process                    Target Process
┌──────────────┐                   ┌──────────────┐
│              │                   │              │
│  Malicious   │                   │  Legitimate  │
│  Code        │                   │  Process     │
│              │     ┌──────────┐  │              │
└──────┬───────┘     │ API:     │  └──────────────┘
       │             │OpenProcess│         ▲
       └────────────►│WriteMemory├─────────┘
                     │CreateThread|  (Inject code)
                     └──────────┘
```

---

## 3. Guided Practice

### Exercise 1: Process Control

Practice process lifecycle management:

```bash
# Start a long-running process
sleep 1000 &

# View its status
jobs
ps aux | grep sleep

# Get its PID
pgrep sleep

# Suspend it
kill -STOP $(pgrep sleep)

# Check state (should show T for stopped)
ps aux | grep sleep

# Resume it
kill -CONT $(pgrep sleep)

# Terminate it
kill $(pgrep sleep)
```

Record your observations:
- PID of your sleep process: ___
- State when running: ___
- State when stopped: ___

### Exercise 2: Memory Inspection

Examine process memory layout:

```bash
# Create a simple process
sleep 1000 &
PID=$!

# View memory map
cat /proc/$PID/maps

# View memory statistics
cat /proc/$PID/status | grep -E 'VmSize|VmRSS|VmData|VmStk'

# Kill the process
kill $PID
```

Questions:
1. What regions do you see in the memory map? ___
2. What is the total virtual memory size? ___
3. What is the actual resident memory (RSS)? ___

### Exercise 3: CPU Analysis

Examine CPU usage:

```bash
# View processes by CPU usage
top -b -n1 | head -20

# View process CPU times
ps aux --sort=-%cpu | head -10

# View scheduler information for a process
cat /proc/1/sched | head -20
```

---

## 4. Reflection Check

### System Understanding
1. If you "kill" a process, what happens to its allocated memory? Who cleans it up?

2. Why is RAM called "volatile" and what are the implications for memory forensics?

3. A process is using 100% CPU. How can it still be "stopped"? What's the difference between stopped and blocked?

### Security Thinking
1. Why do buffer overflows in the stack often lead to code execution? (Hint: return addresses)

2. An attacker has gained arbitrary read access to memory. What valuable information might they extract?

3. Why do operating systems implement virtual memory instead of letting processes use physical memory directly?

---

## 5. Key Misconceptions

**MYTH: "Killing a process immediately frees all its resources"**
REALITY: The process becomes a zombie until the parent collects its exit status. Then resources are freed.

**MYTH: "A process's memory is contiguous in physical RAM"**
REALITY: Virtual memory maps to scattered physical pages. Address space appears contiguous but isn't.

**MYTH: "100% CPU usage means the computer is frozen"**
REALITY: Other processes still get time slices. The scheduler ensures fairness.

**MYTH: "RAM clears instantly on power-off"**
REALITY: Memory contents can persist for seconds to minutes depending on conditions (cold boot attacks).

**MYTH: "Each process can only use one CPU core"**
REALITY: Multi-threaded processes can use multiple cores. Each thread can run on a different core simultaneously.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Distinguish** between programs, processes, and threads
2. **Draw** and explain the process memory layout
3. **Apply** process control commands (signals, states)
4. **Explain** why memory layout matters for security
5. **Understand** CPU scheduling and process states

---

## 7. Further Depth (Optional)

*   **Practice:** Use `strace` to trace system calls of a running process
*   **Exploration:** Learn about /proc filesystem and process information
*   **Research:** Study ASLR (Address Space Layout Randomization) and why it matters
*   **Advanced:** Investigate process injection techniques (DLL injection, process hollowing)
