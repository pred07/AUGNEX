# Insecure Deserialization

## 1. Orientation

### What this module covers
This module covers insecure deserialization—one of the most dangerous vulnerability classes that leads directly to Remote Code Execution (RCE). Understanding serialization and gadget chains is essential for advanced application security.

### Fit in the Learning Path
Deserialization vulnerabilities are "instant RCE" in many cases. They've caused major breaches (Equifax, countless Java applications). While complex, understanding them is essential for comprehensive web application testing.

### Learning Objectives
By the end of this module, you will:
*   Understand serialization and deserialization
*   Identify serialized data in the wild
*   Understand gadget chain concepts
*   Apply deserialization attack tools

---

## 2. Core Content

### Mental Model: The Time Bomb

**How professionals think about this:**
Serialization freezes an object's state for storage or transmission. Deserialization thaws it back into a live object. The danger: when you deserialize untrusted data, you're bringing potentially malicious code to life—like unfreezing a time bomb.

```
SERIALIZATION CONCEPT:

SERIALIZATION (Object → Bytes):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  LIVE OBJECT                      SERIALIZED DATA                  │
│  ┌──────────────┐                 ┌──────────────┐                 │
│  │ User:        │   serialize()   │ {"class":    │                 │
│  │  name: "Bob" │ ───────────────►│  "User",     │                 │
│  │  role: "admin│                 │  "name":"Bob"│                 │
│  │  [methods]   │                 │  "role":...} │                 │
│  └──────────────┘                 └──────────────┘                 │
│                                                                     │
│  Purpose: Store in cookie, send over network, save to file        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

DESERIALIZATION (Bytes → Object):
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  SERIALIZED DATA                  LIVE OBJECT                      │
│  ┌──────────────┐ deserialize()   ┌──────────────┐                 │
│  │ {"class":    │ ───────────────►│ User:        │                 │
│  │  "User",...} │                 │  name: "Bob" │                 │
│  └──────────────┘                 │  [methods    │                 │
│                                   │   executable]│                 │
│                                   └──────────────┘                 │
│                                                                     │
│  DANGER: Attacker controls data → Attacker controls live object   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Why Deserialization is Dangerous

**The execution problem:**

```
DESERIALIZATION DANGER:

THE FUNDAMENTAL ISSUE:
─────────────────────────────
Deserialization instantiates objects
Objects have methods that can execute
Some methods run AUTOMATICALLY:
- Constructors
- Destructors (__destruct in PHP)
- readObject() in Java
- __reduce__ in Python
- Finalizers

ATTACK VECTOR:
─────────────────────────────
1. Application deserializes user input
2. Attacker crafts malicious serialized data
3. Data contains object with dangerous method
4. Deserialization creates object
5. Method executes automatically
6. Attacker achieves RCE

THIS IS NOT A BUG IN THE CODE:
It's a bug in the DESIGN of trusting serialized data
```

### Identifying Serialized Data

**Recognizing formats:**

```
JAVA SERIALIZATION:
─────────────────────────────
Binary format, NOT human readable
Magic bytes: AC ED 00 05
Base64: rO0AB... (starts with rO0)

Finding it:
- Cookies named JSESSIONID (sometimes)
- POST parameters with Base64
- HTTP headers
- File uploads

EXAMPLE (hex):
AC ED 00 05 73 72 00 1A java.util...

PHP SERIALIZATION:
─────────────────────────────
Human readable format:
O:4:"User":2:{s:4:"name";s:5:"alice";s:4:"role";s:5:"admin";}

O:4:"User"  → Object of class "User" (4 chars)
:2:         → Has 2 properties
s:4:"name"  → String of 4 chars: "name"
s:5:"alice" → String of 5 chars: "alice"

PYTHON PICKLE:
─────────────────────────────
Binary format
Magic bytes: 80 03 or 80 04 (protocol version)
Base64 looks like: gASV...

NEVER UNPICKLE UNTRUSTED DATA
It's trivial RCE by design

.NET SERIALIZATION:
─────────────────────────────
Various formatters:
- BinaryFormatter (dangerous)
- TypeNameHandling in JSON.NET
- ViewState (ASP.NET)
- SOAP

Look for: AAEAAAD... (Base64 binary)
```

### Gadget Chains

**The exploitation mechanism:**

```
GADGET CHAIN CONCEPT:

A "gadget" is a class/method that does something useful to attacker
A "chain" links gadgets together to achieve RCE

ANALOGY: RUBE GOLDBERG MACHINE
─────────────────────────────
Ball drops → Triggers lever
Lever → Releases weight
Weight → Hits switch
Switch → Opens door
Door → Cat escapes

GADGET CHAIN:
─────────────────────────────
Object A deserializes → Calls destructor
Destructor → Calls Object B method
Object B method → Processes Object C
Object C → Calls reflection API
Reflection API → Executes shell command

COMMON JAVA GADGET LIBRARIES:
─────────────────────────────
- Apache Commons Collections
- Apache Commons Beanutils
- Spring Framework
- JNDI
- LDAP
- JDK built-in classes

If application has vulnerable library on classpath,
gadget chain exists
```

### Java Deserialization Attacks

**Exploiting Java applications:**

```
JAVA EXPLOITATION:

TOOL: YSOSERIAL
─────────────────────────────
Generates payloads for various gadget chains

java -jar ysoserial.jar CommonsCollections1 "id" > payload.ser

Gadget chains available:
- CommonsCollections1-7
- CommonssBeanutils
- Spring1-4
- JRMPClient
- JNDI (Log4Shell used this)

COMMON LOCATIONS:
─────────────────────────────
- Session cookies
- POST parameters
- JMX interfaces
- RMI interfaces
- Custom network protocols
- Message queues (JMS)

ATTACK PROCESS:
─────────────────────────────
1. Identify serialized Java data (AC ED or rO0)
2. Identify libraries on target (error messages, headers)
3. Generate payload with ysoserial
4. Replace legitimate serialized data with payload
5. Application deserializes
6. Gadget chain executes
7. RCE achieved
```

### PHP Deserialization Attacks

**Exploiting PHP applications:**

```
PHP EXPLOITATION:

MAGIC METHODS:
─────────────────────────────
__construct()  - Called on object creation
__destruct()   - Called on object destruction
__wakeup()     - Called on deserialization
__toString()   - Called when object used as string
__call()       - Called when undefined method invoked

ATTACK EXAMPLE:
─────────────────────────────
Vulnerable class:
class FileHandler {
    public $filename;
    function __destruct() {
        unlink($this->filename);  // Deletes file!
    }
}

Attacker input:
O:11:"FileHandler":1:{s:8:"filename";s:11:"/etc/passwd";}

When deserialized and destructed:
→ Deletes /etc/passwd

PROPERTY-ORIENTED PROGRAMMING (POP):
─────────────────────────────
Chain multiple classes together
Like gadget chains in Java
But using __destruct, __wakeup, __toString
```

### Python Pickle Attacks

**Exploiting Python applications:**

```
PYTHON PICKLE:

PICKLE IS RCE BY DESIGN:
─────────────────────────────
__reduce__ method controls unpickling
Can specify arbitrary function + arguments

SIMPLE RCE PAYLOAD:
─────────────────────────────
import pickle
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('id',))

payload = pickle.dumps(Exploit())
# Send this to vulnerable endpoint

COMMON LOCATIONS:
─────────────────────────────
- Redis (stores pickled Python objects)
- Memcached
- Custom web frameworks
- Scientific computing (numpy, pandas)
- Machine learning (model files!)

ML MODEL BACKDOORS:
─────────────────────────────
Pickle models can contain malicious code
Loading untrusted .pkl file = RCE
This is a real supply chain attack vector
```

### Defense Strategies

**Preventing deserialization attacks:**

```
DESERIALIZATION DEFENSES:

1. DON'T DESERIALIZE UNTRUSTED DATA
   ─────────────────────────────
   Best defense: Don't do it
   Use safer formats: JSON, XML (without entity expansion)
   Avoid native serialization entirely

2. INPUT VALIDATION (WEAK)
   ─────────────────────────────
   Validate BEFORE deserialization
   Problem: Hard to validate binary formats
   
3. SIGNATURE/ENCRYPTION
   ─────────────────────────────
   Sign serialized data (like JWT)
   Reject if signature invalid
   Encrypt to prevent tampering
   
   Risk: Key management, still processing data

4. CLASS WHITELISTING
   ─────────────────────────────
   Java: Implement ObjectInputFilter
   Only allow specific safe classes
   Deny all others
   
5. REMOVE VULNERABLE LIBRARIES
   ─────────────────────────────
   If Commons Collections not needed, remove it
   No library = No gadget chain
   
6. LANGUAGE-SPECIFIC
   ─────────────────────────────
   PHP: Use json_encode/decode instead
   Python: Never use pickle for untrusted data
   Java: Avoid ObjectInputStream for user input
   .NET: Avoid BinaryFormatter, TypeNameHandling
```

---

## 3. Guided Practice

### Exercise 1: Identify Serialized Data

What format is each?

| Data | Format |
|------|--------|
| `rO0ABXNyABNqYXZhLn...` | ___ |
| `O:4:"User":1:{s...}` | ___ |
| `gASVLgAAAAAAAA...` | ___ |
| `AAEAAAD/////AQ...` | ___ |

### Exercise 2: PHP Deserialization

Given this class:
```php
class Logger {
    public $logfile;
    function __destruct() {
        file_put_contents($this->logfile, "logged");
    }
}
```

Write a malicious serialized object to write to `/tmp/pwned`:
___

### Exercise 3: Attack Planning

Application uses Java with Commons Collections 3.1. Serialized data in cookie.

1. Tool to generate payload: ___
2. Gadget chain to use: ___
3. How to get command output back: ___

---

## 4. Reflection Check

### Deserialization Understanding
1. Why is JSON safer than native serialization?

2. Application signs serialized data. Still vulnerable?

3. Pickle is "never safe" but widely used. Why?

### Attack Thinking
1. Java app, unknown libraries on classpath. Approach?

2. PHP deserialization, no obvious dangerous classes. Dead end?

3. Got RCE but it's blind (no output). How to confirm?

---

## 5. Key Misconceptions

**MYTH: "Deserialization is just data parsing"**
REALITY: Deserialization creates live, executable objects. It's code execution disguised as data parsing.

**MYTH: "If I don't use the dangerous classes, I'm safe"**
REALITY: Libraries on your classpath may contain gadgets. You don't control what's available.

**MYTH: "Validating data prevents attacks"**
REALITY: Validation happens AFTER parsing. The damage may already be done during deserialization.

**MYTH: "This only affects old applications"**
REALITY: Log4Shell (2021) was a deserialization attack. These vulns are current and widespread.

**MYTH: "Python pickle is okay for internal use"**
REALITY: Internal data can be manipulated (MITM, compromised storage). Pickle is dangerous anywhere.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Identify** serialized data formats (Java, PHP, Python)
2. **Understand** gadget chain concepts
3. **Use** ysoserial for Java exploitation
4. **Explain** why deserialization leads to RCE
5. **Apply** defense strategies

---

## 7. Further Depth (Optional)

*   **Tool:** Practice with ysoserial, PHPGGC
*   **Labs:** PortSwigger Deserialization labs
*   **Research:** Java deserialization research papers
*   **Advanced:** Write custom gadget chains
