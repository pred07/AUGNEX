# Introduction to Cybersecurity and Computing Systems

## 1. Orientation

### What this module covers
This module establishes the foundational mental model that separates security professionals from casual users. You will learn to see a computer not as a tool, but as a layered system of trust boundaries, privilege levels, and controlled chaos. Every vulnerability, every attack, and every defense mechanism you will encounter in your career traces back to the concepts introduced here.

### Fit in the Learning Path
This is the **first step** of the FORGE path. Before you can secure systems (Defense) or compromise them (Offense), you must internalize how they actually function. Skipping this creates dangerous blind spots—practitioners who know *what* happens but not *why* it happens will fail at scale.

### Learning Objectives
By the end of this module, you will:
*   Understand the three-layer architecture of computing systems (Hardware → Kernel → User Space)
*   Internalize the concept of Privilege Rings and why Ring 0/Ring 3 separation exists
*   Apply the CIA Triad as a technical framework, not just a theoretical model
*   Recognize where security boundaries exist and why attackers target them

---

## 2. Core Content

### Mental Model: The Computer as a Trust Hierarchy

**How professionals think about this:**
A computer is not a single entity—it is a strict hierarchy of trust levels. At every layer, the question is the same: *"Who is allowed to do what, and who enforces that?"*

Security professionals see systems as **concentric rings of decreasing trust**:
- The innermost ring has absolute power (hardware/firmware)
- Each outer ring has progressively restricted capabilities
- Every interaction between rings is a potential attack surface

### The Three Layers of Computing

#### 1. Hardware (The Physical Foundation)
The CPU, RAM, storage, and peripherals. Hardware executes instructions blindly—it has no concept of "good" or "bad" code. It follows the instruction pointer wherever it leads.

**Critical insight:** Hardware vulnerabilities (Spectre, Meltdown, Rowhammer) are devastating because they bypass *all* software protections. The software security model assumes hardware behaves correctly. When it doesn't, everything built on top fails.

**Real-world failure:** In 2018, Spectre and Meltdown revealed that CPU optimizations (speculative execution) created side-channel attacks that leaked memory across privilege boundaries. Every major processor was affected. This demonstrated that hardware-level assumptions in security models can be fatally wrong.

#### 2. The Kernel (The Gatekeeper)
The kernel is the core of the operating system. It manages:
- **Memory allocation**: Which processes can access which memory regions
- **Process scheduling**: When each process gets CPU time
- **Hardware abstraction**: Providing consistent interfaces to diverse hardware
- **Permission enforcement**: Deciding what each process can and cannot do

**Critical insight:** The kernel runs in **Ring 0** (highest privilege). A kernel bug doesn't just affect one application—it compromises the entire system. This is why kernel exploits are the most valuable and dangerous.

**Attacker perspective:** Kernel exploits are the "holy grail" because they provide:
- Complete control over the system
- Ability to hide from all user-space security tools
- Persistence that survives application restarts

**Defender perspective:** Kernel hardening is critical but difficult:
- Kernel Address Space Layout Randomization (KASLR)
- Secure boot chains to verify kernel integrity
- Minimal kernel attack surface (microkernels vs monolithic)

#### 3. User Space (The Sandboxed World)
Where applications live—your browser, email client, security tools. User space programs run in **Ring 3** (lowest privilege) and cannot directly access hardware or other processes' memory.

**The System Call barrier:** When a user-space program needs something from the kernel (file access, network connection, memory allocation), it must make a **system call**. This is a controlled gate where the kernel validates the request.

**Critical insight:** The system call interface is one of the most audited and attacked surfaces in any OS. Every syscall is a potential vulnerability if not properly validated.

### Privilege Rings: The x86 Security Model

```
Ring 0 (Kernel Mode)     → Full hardware access, all instructions allowed
Ring 1-2 (Device Drivers) → Rarely used in modern OS
Ring 3 (User Mode)        → Restricted, cannot execute privileged instructions
```

**Why this matters:**
- Ring transitions are expensive (context switches)
- Hypervisors introduced Ring -1 (VMX root mode) for virtualization
- Modern CPUs added Ring -2 (SMM) and Ring -3 (ME/PSP) for firmware

**Engineering trade-off:** More rings = more isolation = more overhead. Linux and Windows use only Ring 0 and Ring 3 for simplicity and performance.

### The CIA Triad as Technical Reality

The CIA Triad is not an abstract concept—it maps directly to system mechanisms:

| Principle | Technical Implementation | Attack Type |
|-----------|-------------------------|-------------|
| **Confidentiality** | File permissions, encryption, memory isolation | Data exfiltration, side-channels |
| **Integrity** | Hashing, digital signatures, code signing | Tampering, MITM, supply chain |
| **Availability** | Redundancy, rate limiting, resource quotas | DoS, resource exhaustion |

**Professional insight:** Most security controls address only one or two CIA properties. Encryption provides confidentiality and integrity, but not availability. Understanding these trade-offs is essential for architecture decisions.

### Where Boundaries Fail

**Common misconfigurations:**
1. **Shared kernel vulnerabilities**: Containers share the host kernel—a kernel exploit escapes all containers
2. **Overprivileged services**: Running applications as root/SYSTEM when they don't need it
3. **Trust boundary confusion**: Assuming network isolation equals security isolation

**What breaks at scale:**
- Permission models become impossible to audit manually
- Privilege creep accumulates over time
- Legacy exceptions become permanent attack surface

---

## 3. Guided Practice

### Exercise 1: Identify Your Trust Boundaries

**Objective:** Map where you sit in the privilege hierarchy right now.

**Step 1: Determine your OS and kernel version**

*Windows:*
```powershell
[System.Environment]::OSVersion
Get-WmiObject Win32_OperatingSystem | Select-Object Caption, Version, BuildNumber
```

*Linux/macOS:*
```bash
uname -a
cat /etc/os-release   # Linux only
```

**Step 2: Identify your current privilege level**
```bash
whoami
id   # Linux/macOS - shows UID and groups
```

**Analysis questions:**
- Are you running as a privileged user (root/Administrator)?
- If so, why? Is that necessary for your current task?
- What would change if you were in a lower-privilege context?

### Exercise 2: Observe System Call Activity

**Objective:** See the kernel boundary in action.

*Linux:*
```bash
strace ls /tmp 2>&1 | head -20
```

*macOS:*
```bash
dtruss ls /tmp 2>&1 | head -20
```

*Windows (requires SysInternals):*
```powershell
procmon.exe  # Observe syscalls in real-time
```

**What to observe:**
- `open()`, `read()`, `write()` - file operations crossing into kernel
- `mmap()` - memory allocation requests
- Notice how many kernel calls even a simple `ls` requires

---

## 4. Reflection Check

### Attacker Perspective
1. Why is a kernel vulnerability worth more than an application vulnerability on the exploit market?
2. If you control Ring 0, what can you do that Ring 3 cannot?
3. How does the concept of "escape" (container escape, sandbox escape) relate to privilege rings?

### Defender Perspective
1. Why do modern operating systems use Address Space Layout Randomization (ASLR)?
2. What is the security benefit of running services in containers vs directly on the host?
3. Why might a "defense in depth" strategy be necessary if the kernel can be compromised?

### Engineering Perspective
1. What is the performance cost of adding more privilege boundaries?
2. Why did hypervisors need to introduce Ring -1 instead of running in Ring 0?
3. How does hardware-enforced isolation (Intel SGX, ARM TrustZone) change the trust model?

---

## 5. Key Misconceptions

**MYTH: "Administrator/root means unlimited power"**
REALITY: Even root runs in user space. The kernel still mediates all hardware access.

**MYTH: "Antivirus can detect all malware"**
REALITY: User-space security tools cannot see Ring 0 activity. Rootkits operate below them.

**MYTH: "Containers provide strong isolation"**
REALITY: Containers share the kernel. A kernel exploit breaks all container isolation.

**MYTH: "The security boundary is at the network firewall"**
REALITY: The most critical boundary is between Ring 3 and Ring 0 on every machine.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Explain** the three-layer computing model (Hardware → Kernel → User Space) without notes
2. **Identify** which privilege ring a given process operates in
3. **Articulate** why kernel vulnerabilities are more severe than application vulnerabilities
4. **Apply** the CIA Triad to a specific technical control (e.g., explain how file permissions implement confidentiality)
5. **Recognize** that "root" is still constrained by the kernel/hardware boundary

---

## 7. Further Depth (Optional)

For those seeking deeper understanding:

*   **Reading**: "Understanding the Linux Kernel" by Bovet & Cesati (Chapters 1-3)
*   **Research**: Spectre and Meltdown papers (2018) - how hardware assumptions failed
*   **Exploration**: Boot a minimal Linux kernel and observe the init process
*   **Historical context**: Research "Killer Poke" incidents where software damaged hardware
