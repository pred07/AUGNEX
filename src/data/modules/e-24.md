# Authentication Attacks and Logic Flaws

## 1. Orientation

### What this module covers
This module covers flaws in authentication design and business logic—vulnerabilities that exist because the workflow is wrong, not because a single line of code is insecure. Logic flaws and race conditions are where human testers excel.

### Fit in the Learning Path
Automated scanners struggle with logic flaws—they require understanding of intended behavior to recognize unintended behavior. This is where thinking like an attacker, not just running tools, provides value.

### Learning Objectives
By the end of this module, you will:
*   Identify business logic vulnerabilities
*   Exploit race conditions (TOCTOU)
*   Bypass multi-step authentication
*   Test authentication workflows systematically

---

## 2. Core Content

### Mental Model: Flow vs Function

**How professionals think about this:**
Code can be syntactically correct but logically broken. Logic flaws exist in the FLOW between functions, not within individual functions. You must understand the intended workflow to find where it breaks.

```
LOGIC FLAW CONCEPT:

INTENDED FLOW:
Step 1 → Step 2 → Step 3 → Success
   │         │         │
   ↓         ↓         ↓
Validate   Verify    Complete
 user       2FA      action

ATTACKER TESTS:
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  Can I skip steps?                                                  │
│  Step 1 → [skip Step 2] → Step 3?                                  │
│                                                                     │
│  Can I reorder steps?                                               │
│  Step 2 → Step 1 → Step 3?                                         │
│                                                                     │
│  Can I repeat steps?                                                │
│  Step 1 → Step 2 → Step 2 → Step 2?                                │
│                                                                     │
│  Can I use step data from different context?                        │
│  Account A Step 1 → Account B Step 2?                              │
│                                                                     │
│  Can I manipulate state between steps?                              │
│  Step 1 → [modify cart] → Step 3?                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

If any "No" becomes "Yes" = Logic vulnerability
```

### Common Logic Flaw Patterns

**Authentication bypasses:**

```
AUTHENTICATION LOGIC FLAWS:

1. STEP SKIPPING
   ─────────────────
   Flow: Login → 2FA → Dashboard
   Attack: Access /dashboard directly after login
   
   Vulnerable if: Server doesn't verify 2FA completion
   
2. RESPONSE MANIPULATION
   ─────────────────
   Response: {"success": false, "2fa_required": true}
   Attack: Modify to {"success": true, "2fa_required": false}
   
   Vulnerable if: Client-side flow control

3. PARAMETER MODIFICATION
   ─────────────────
   Request: POST /verify?user_id=123&code=5555
   Attack: Change user_id to victim's, use your code
   
   Vulnerable if: Token not bound to user

4. RECOVERY FLOW ABUSE
   ─────────────────
   Password reset → Get token → (attack window) → Set password
   Attack: Use token for different account
   
   Vulnerable if: Token not user-bound
```

**E-commerce logic flaws:**

```
PRICING LOGIC FLAWS:

1. NEGATIVE QUANTITY
   ─────────────────
   Request: quantity=-1, price=$100
   Result: Total = -$100 (credit?)
   
2. PRICE MANIPULATION
   ─────────────────
   Hidden field: <input type="hidden" name="price" value="100">
   Attack: Change to value="1"
   
3. RACE CONDITION ON DISCOUNT
   ─────────────────
   "50% off, one use only"
   Attack: Send 10 concurrent requests
   Result: Discount applied 10 times

4. GIFT CARD/CREDIT ABUSE
   ─────────────────
   Transfer credit between accounts
   Attack: Transfer $100 to self, race condition → $1000
   
5. CHECKOUT STATE MANIPULATION
   ─────────────────
   Add item ($100) → Checkout → Remove item → Pay
   Result: Pay $0, order processes
```

### Race Conditions (TOCTOU)

**Time-of-Check to Time-of-Use:**

```
RACE CONDITION MECHANICS:

NORMAL FLOW (single request):
┌────────────────────────────────────────────────────────────┐
│ Time →                                                     │
│ ──────                                                     │
│ [Check balance ≥ $10] → [Deduct $10] → [Transfer $10]      │
│         t=0                t=1             t=2              │
│                                                            │
│ Balance: $10 → $10 → $0 → $0                               │
│                                                            │
└────────────────────────────────────────────────────────────┘

RACE CONDITION (concurrent requests):
┌────────────────────────────────────────────────────────────┐
│ Time →                                                     │
│ ──────                                                     │
│ Request 1: [Check ≥$10✓]     [Deduct]     [Transfer]       │
│                  │              │             │            │
│ Request 2: [Check ≥$10✓]     [Deduct]     [Transfer]       │
│                  │              │             │            │
│ Request 3: [Check ≥$10✓]     [Deduct]     [Transfer]       │
│                                                            │
│ All checks pass before any deduct!                         │
│ Result: Transfer $30 with $10 balance                      │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

**Exploiting race conditions:**

```bash
# Using Burp Suite Turbo Intruder
# (sends requests in parallel on single connection)

# Using curl in parallel
seq 1 100 | xargs -P 100 -I {} curl -X POST \
  --cookie "session=abc" \
  "https://target.com/transfer?amount=100"

# Using Python threading
import threading
import requests

def transfer():
    requests.post("https://target.com/transfer", 
                  data={"amount": 100},
                  cookies={"session": "abc"})

threads = [threading.Thread(target=transfer) for _ in range(100)]
for t in threads: t.start()
for t in threads: t.join()
```

### Multi-Factor Authentication Bypasses

**2FA logic flaws:**

| Bypass Type | Technique |
|-------------|-----------|
| **Skip 2FA page** | Access authenticated endpoint directly |
| **Code brute force** | 6 digits = 1M options, check rate limits |
| **Code reuse** | Use old valid codes |
| **Backup code abuse** | Generate, use, or brute force backup codes |
| **Response manipulation** | Change error to success in response |
| **Fallback method** | Switch to weaker SMS, then SIM swap |
| **Session confusion** | Use 2FA-verified session from another account |
| **Null/empty code** | Submit empty code field |

```
2FA BYPASS TESTING:

1. Complete Step 1 (password auth)
2. Note session cookie state
3. Instead of Step 2 (2FA):
   - Try accessing /dashboard
   - Try accessing /account  
   - Try accessing any authenticated endpoint
   
4. If access granted → 2FA bypass

5. Also test:
   - Brute force code (check 1000+ attempts allowed?)
   - Reuse previously valid code
   - Use code from different account
   - Manipulate response from false → true
```

### Account Takeover Logic Chains

**Combining flaws:**

```
ACCOUNT TAKEOVER CHAINS:

Chain 1: Password Reset + User Enumeration
──────────────────────────────────────────
1. Enumerate valid emails via reset response
2. Reset password, weak token generation
3. Brute force or predict token
4. Set new password

Chain 2: 2FA Bypass + Session Fixation
──────────────────────────────────────────
1. Start login, get session before 2FA
2. Send session to victim
3. Victim completes login + 2FA
4. Your session now authenticated

Chain 3: OAuth Misconfiguration
──────────────────────────────────────────
1. Initiate OAuth with redirect_uri=attacker.com
2. Victim authenticates
3. Token redirected to attacker
4. Attacker uses token to login
```

### Testing Methodology

**Systematic logic flaw hunting:**

```
LOGIC FLAW TESTING METHODOLOGY:

1. MAP THE WORKFLOW
   - Document every step
   - Document every state change
   - Document every request/response
   
2. IDENTIFY ASSUMPTIONS
   - What does the app assume you'll do?
   - What order is expected?
   - What values are expected?
   
3. VIOLATE ASSUMPTIONS
   - Skip steps
   - Reorder steps
   - Repeat steps
   - Use negative values
   - Use zero values
   - Use extreme values
   - Change user context mid-flow
   
4. TEST STATE ISOLATION
   - Can state from User A affect User B?
   - Can state from Session A affect Session B?
   - Can old state affect new state?
   
5. TEST CONCURRENCY
   - Send parallel requests
   - Target check-then-act patterns
   - Target limited resources (discounts, inventory)
```

### Coupon and Discount Abuse

**Common patterns:**

```
DISCOUNT LOGIC TESTING:

1. REUSE SINGLE-USE CODES
   Apply → Remove → Apply → Remove → Apply...
   
2. STACK DISCOUNTS
   DISCOUNT10 + DISCOUNT20 = 30%? 100%?
   
3. CONCURRENT APPLICATION
   Send 10 requests with same code simultaneously
   
4. APPLY TO DIFFERENT ACCOUNT
   Get code for Account A, use on Account B
   
5. NEGATIVE DISCOUNTS
   discount_percent=-100 (price doubles? or credit?)
   
6. CODE GENERATION PREDICTION
   If codes are: NEWUSER2024A, NEWUSER2024B...
   Try: NEWUSER2024C, NEWUSER2024Z
```

---

## 3. Guided Practice

### Exercise 1: Workflow Mapping

For a password reset flow:
1. List the steps: ___
2. What happens if you skip step 2? ___
3. What happens if you repeat step 3? ___

### Exercise 2: Race Condition Identification

Given this flow:
```
if balance >= amount:
    balance = balance - amount
    send_money(recipient, amount)
```

1. Why is this vulnerable? ___
2. What's the attack? ___
3. How would you fix it? ___

### Exercise 3: 2FA Bypass Testing

You see this 2FA flow:
```
POST /login → 200, sets session=abc
GET /2fa → Shows 2FA form
POST /verify-2fa → If correct, redirects to /dashboard
```

What would you try to bypass 2FA?

1. ___
2. ___
3. ___

---

## 4. Reflection Check

### Understanding Logic Flaws
1. Why can't automated scanners reliably find logic flaws?

2. A checkout process has 5 steps. What's the minimum number of tests to find step-skipping bugs?

3. Race conditions require parallel requests. What determines how many parallel requests you need?

### Attack Thinking
1. You have a "one-time use" coupon. How would you try to use it multiple times?

2. 2FA codes are 4 digits. Rate limiting locks after 5 attempts. How might you still brute force?

3. The app lets you transfer credits between your accounts. What logic flaw might exist?

---

## 5. Key Misconceptions

**MYTH: "The code is syntactically correct, so it's secure"**
REALITY: Logic flaws exist in design, not syntax. Correct code can have incorrect logic.

**MYTH: "Users will follow the intended workflow"**
REALITY: Attackers deliberately deviate. Test what happens when steps are skipped/reordered.

**MYTH: "Race conditions are too hard to exploit"**
REALITY: With proper tooling (Turbo Intruder), race conditions are practical attacks.

**MYTH: "2FA makes accounts secure"**
REALITY: 2FA implementation flaws (skip, brute force, fallback) are common.

**MYTH: "We test functionality, that covers security"**
REALITY: Functional testing confirms intended behavior. Security testing confirms unintended behavior fails.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Identify** logic flaw patterns in authentication workflows
2. **Exploit** race conditions conceptually
3. **Test** multi-step processes for skip/reorder vulnerabilities
4. **Apply** systematic methodology to find logic flaws
5. **Recognize** the limitations of automated scanning for logic issues

---

## 7. Further Depth (Optional)

*   **Practice:** PortSwigger Business Logic labs
*   **Tool:** Burp Suite Turbo Intruder for race conditions
*   **Research:** Study real-world logic flaw bug bounty reports
*   **Reading:** OWASP Testing Guide - Business Logic section
