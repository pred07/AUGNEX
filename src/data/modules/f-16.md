# Package Management and Updates

## 1. Orientation

### What this module covers
This module examines software management in Linux—how packages are installed, updated, and removed. We focus on APT (Debian/Ubuntu/Kali), while covering the broader ecosystem including alternative package managers, supply chain security, and the security implications of software installation.

### Fit in the Learning Path
Understanding package management is essential for maintaining systems and installing security tools. More critically, the software supply chain is a major attack surface—compromised packages lead to compromised systems.

### Learning Objectives
By the end of this module, you will:
*   Understand the repository-based package model
*   Master essential APT commands
*   Recognize supply chain security risks
*   Install software from alternative sources safely

---

## 2. Core Content

### Mental Model: The Software Supply Chain

**How professionals think about this:**
Every package you install is code you're trusting to run on your system. The supply chain—from developer to repository to your machine—is a chain of trust that can be compromised at any point.

```
PACKAGE SUPPLY CHAIN:

┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  DEVELOPER                                                          │
│     │                                                               │
│     │ Writes code                                                   │
│     ▼                                                               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  SOURCE REPOSITORY (GitHub, GitLab)                         │   │
│  │  - Code hosted                                               │   │
│  │  - Attack: Compromised developer account                     │   │
│  └────────────────────────────┬────────────────────────────────┘   │
│                               │                                     │
│                          Packaged                                   │
│                               │                                     │
│  ┌────────────────────────────▼────────────────────────────────┐   │
│  │  DISTRIBUTION REPOSITORY (Debian, Kali repos)               │   │
│  │  - Packages signed by maintainers                            │   │
│  │  - Dependencies resolved                                     │   │
│  │  - Attack: Compromised repo, malicious maintainer           │   │
│  └────────────────────────────┬────────────────────────────────┘   │
│                               │                                     │
│                        Downloaded                                   │
│                               │                                     │
│  ┌────────────────────────────▼────────────────────────────────┐   │
│  │  YOUR SYSTEM                                                 │   │
│  │  - Package verified (GPG signature)                          │   │
│  │  - Dependencies installed                                    │   │
│  │  - Code runs with your privileges                            │   │
│  │  - Attack: Malicious package now has access                 │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### The Repository Model

**Why repositories exist:**

| Benefit | Explanation |
|---------|-------------|
| **Centralized source** | One trusted location for software |
| **Dependency resolution** | Package manager installs requirements |
| **Cryptographic signing** | Packages verified before installation |
| **Version tracking** | Known-good versions maintained |
| **Security updates** | Patches distributed efficiently |

**Repository types:**

```
REPOSITORY CLASSIFICATIONS:

OFFICIAL REPOSITORIES:
├── Main/Core - Essential packages
├── Security - Security patches
├── Updates - Bug fixes
└── Backports - Newer packages for stable

THIRD-PARTY REPOSITORIES:
├── PPAs (Personal Package Archives) - Ubuntu
├── Third-party repos - Added manually
└── Risk: Less vetting, potential for compromise

SOURCES.LIST EXAMPLE:
/etc/apt/sources.list:
deb http://http.kali.org/kali kali-rolling main contrib non-free
deb-src http://http.kali.org/kali kali-rolling main contrib non-free
```

### APT Command Reference

**Essential commands:**

```bash
# Update package list (NOT upgrade software)
sudo apt update
# Downloads latest package metadata from repositories
# Think: "What versions are available?"

# Upgrade all packages
sudo apt upgrade
# Installs newer versions of installed packages
# Think: "Install those newer versions"

# Full upgrade (handles dependency changes)
sudo apt full-upgrade
# Removes/adds packages as needed for upgrade

# Install package
sudo apt install <package>
# Download and install package with dependencies

# Remove package
sudo apt remove <package>
# Remove package, keep configuration

# Purge package
sudo apt purge <package>
# Remove package AND configuration files

# Search for packages
apt search <keyword>

# Show package details
apt show <package>

# List installed packages
dpkg -l
apt list --installed

# Clean cached packages
sudo apt clean
sudo apt autoremove
```

**Important distinction:**

```
apt update vs apt upgrade:

apt update:
  ┌─────────────┐     ┌─────────────┐
  │ Your system │ ←── │ Repository  │
  │             │     │ metadata    │
  │ "What's new?"     │ (versions)  │
  └─────────────┘     └─────────────┘
  
  Result: Package list refreshed
  Nothing installed or upgraded yet

apt upgrade:
  ┌─────────────┐     ┌─────────────┐
  │ Your system │ ←── │ Repository  │
  │             │     │ packages    │
  │ "Give me    │     │ (binaries)  │
  │  new stuff" │     │             │
  └─────────────┘     └─────────────┘
  
  Result: Packages actually upgraded

ALWAYS RUN BOTH:
sudo apt update && sudo apt upgrade
```

### Package Management Security

**Verification mechanisms:**

```
GPG SIGNATURE VERIFICATION:

When you apt install:
1. Package downloaded from repository
2. GPG signature checked against repo key
3. Hash verified
4. Only then: installed

Repository keys stored in:
/etc/apt/trusted.gpg.d/

If signature fails: Installation blocked
Attack: Add malicious repo with attacker's key
```

**Supply chain attack vectors:**

| Attack Vector | Example | Mitigation |
|---------------|---------|------------|
| **Compromised repo** | Attacker gains repo access | Use official repos, verify signatures |
| **Typosquatting** | python-requests vs python-request | Verify package name carefully |
| **Dependency confusion** | Internal vs public package names | Scoped registries |
| **Maintainer compromise** | Attacker gains maintainer account | Multiple maintainer review |
| **Build system compromise** | CI/CD pipeline attacked | Reproducible builds |

### Alternative Package Sources

**When APT isn't enough:**

```
PACKAGE SOURCE HIERARCHY (Preferred order):

1. OFFICIAL APT REPOS
   - Most trusted, maintained by distro
   sudo apt install <package>

2. OFFICIAL VENDOR REPOS
   - Added manually, maintained by software vendor
   # Example: Adding Docker's official repo
   
3. SNAP/FLATPAK
   - Sandboxed packages
   sudo snap install <package>
   
4. LANGUAGE-SPECIFIC MANAGERS
   pip install <package>      # Python
   npm install <package>      # Node.js
   gem install <package>      # Ruby

5. GITHUB/SOURCE
   - Direct from developer, no distro vetting
   git clone <repo>
   
6. RANDOM WEBSITES
   - AVOID unless absolutely necessary
   - Verify checksums manually
```

**Python pip security:**

```bash
# Install Python package
pip3 install <package>

# Install specific version (security pinning)
pip3 install package==1.2.3

# Install from requirements file
pip3 install -r requirements.txt

# Security concerns:
# - PyPI has limited malware scanning
# - Typosquatting common
# - Dependencies can be malicious

# Better: Use virtual environments
python3 -m venv myenv
source myenv/bin/activate
pip install <package>
```

**Installing from source:**

```bash
# Clone and build
git clone https://github.com/user/tool.git
cd tool
make
sudo make install

# Verify before building:
# - Check stars/forks (popularity)
# - Read the code if possible
# - Check for recent activity
# - Look for security advisories
```

### Offline Installation

**Air-gapped systems:**

```bash
# Download package with dependencies on internet-connected machine
apt-get download <package>
apt-get download $(apt-cache depends --recurse --no-recommends \
  --no-suggests --no-conflicts --no-breaks --no-replaces \
  --no-enhances <package> | grep "^\w" | sort -u)

# Transfer via USB/media to air-gapped system

# Install locally
dpkg -i *.deb

# Or use apt with local repository
```

### Rolling vs Stable Releases

**Understanding release models:**

| Model | Example | Updates | Use Case |
|-------|---------|---------|----------|
| **Stable** | Debian Stable | Infrequent, tested | Production servers |
| **Rolling** | Kali, Arch | Continuous | Security tools, dev |
| **LTS** | Ubuntu LTS | 5 years support | Enterprise |

```
STABILITY VS FRESHNESS:

STABLE (Debian Stable):
├── Packages frozen at release
├── Security patches backported
├── Very reliable, predictable
└── May lack newest tools

ROLLING (Kali):
├── Always latest versions
├── Newest security tools
├── May have instability
└── Better for testing, worse for production
```

---

## 3. Guided Practice

### Exercise 1: APT Basics

Execute and record:

```bash
# Refresh package list
sudo apt update
```
Output shows: ___

```bash
# Search for a package
apt search nmap
```
Versions available: ___

```bash
# Install and verify
sudo apt install neofetch
neofetch
```

```bash
# Remove cleanly
sudo apt purge neofetch
sudo apt autoremove
```

### Exercise 2: Repository Inspection

Examine your sources:

```bash
cat /etc/apt/sources.list
ls /etc/apt/sources.list.d/
```

Questions:
- What repositories are configured? ___
- Are there any third-party repos? ___

### Exercise 3: Supply Chain Thinking

For each installation method, rate the risk (H/M/L):

| Method | Risk | Justification |
|--------|------|---------------|
| apt install from official repo | ___ | ___ |
| pip install from PyPI | ___ | ___ |
| git clone random GitHub repo | ___ | ___ |
| Download .deb from website | ___ | ___ |

---

## 4. Reflection Check

### Package Management Understanding
1. Why must you run `apt update` before `apt upgrade`?

2. A package installation fails GPG verification. What should you do?

3. You need a tool that's not in the official repos. What's your safest approach?

### Security Thinking
1. An attacker compromises the Kali repository. How many systems could be affected?

2. A Python package you use daily was found to contain malware. How would you check if you're affected?

3. You're setting up an air-gapped network. How do you get security tools on the systems?

---

## 5. Key Misconceptions

**MYTH: "Official repos are always safe"**
REALITY: Supply chain attacks on official repos have occurred. Trust but verify.

**MYTH: "pip/npm packages are safe if they're popular"**
REALITY: Popularity doesn't equal security. Popular packages have been compromised.

**MYTH: "apt update upgrades my system"**
REALITY: apt update only refreshes the package list. apt upgrade performs the actual update.

**MYTH: "Building from source is safer"**
REALITY: Building from source bypasses distro vetting. You're trusting the source directly.

**MYTH: "Old packages are safer because they're tested"**
REALITY: Old packages may have known vulnerabilities. Balance stability with security updates.

---

## 6. Completion Criteria

This module is complete when you can:

1. **Execute** update/upgrade/install/remove cycle
2. **Explain** the difference between apt update and upgrade
3. **Identify** security risks in package installation
4. **Install** software from non-APT sources safely
5. **Verify** package authenticity concepts

---

## 7. Further Depth (Optional)

*   **Security:** Monitor security advisories for your distro
*   **Practice:** Set up a local package mirror
*   **Tool:** Learn to create .deb packages
*   **Research:** Supply chain attack case studies
