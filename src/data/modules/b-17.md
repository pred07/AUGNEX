# Terraform for Security Engineers

## 1. Tactical Orientation

### Scope of Operations
This module moves beyond "how to deploy resources" to **"how to deploy securely and manage state at scale."** As a Security Engineer, your role is not just to write HCL, but to architect the guardrails that prevent developers from deploying insecure infrastructure. We focus on **State Security**, **Secret Management**, and **Policy-as-Code**.

### Operational Objectives
By the end of this rotation, you will be able to:
*   **Secure the State:** Implement remote backends with encryption-at-rest and strict locking.
*   **Eliminate Secrets:** Replace plaintext variables with dynamic secret injection (Vault/KMS).
*   **Enforce Policy:** Write Sentinel or OPA policies that *prevent* insecure deployments before they happen.
*   **Detect Drift:** Identify when manual changes have compromised your immutable infrastructure.

---

## 2. Engineering Theory

### The State File: The "Crown Jewels"
The `terraform.tfstate` file is the single most sensitive artifact in your cloud engineering stack.
*   **Risk:** It maps resource IDs to real-world infrastructure and often contains *decrypted* output values (database passwords, private keys) even if you treat them as "sensitive" variables.
*   **Engineering Control:** NEVER store state locally or in Git.
    *   **Remote Backend:** Use S3 (AWS) or GCS (GCP) with **Versioning** enabled (for rollback).
    *   **Encryption:** Enable server-side encryption (SSE-KMS) with a dedicated CMK (Customer Master Key).
    *   **Locking:** Use DynamoDB to prevent race conditions during concurrent builds.

### Secrets Management: The "No-Code" Rule
Hardcoding credentials in `variables.tf` is a critical failure.
*   **Anti-Pattern:** Passing secrets via environment variables in CI/CD (visible in process dumps).
*   **Engineering Pattern:** **Just-in-Time (JIT) retrieval**.
    *   Terraform authenticates to HashiCorp Vault or AWS Secrets Manager.
    *   It requests a distinct, short-lived credential for the deployment.
    *   The secret never touches the disk or the Git history.

### Policy-as-Code (PaC)
Security reviews cannot scale if they are manual. PaC automated the "Security Review" phase.
*   **OPA (Open Policy Agent) / Rego:** Checks the *JSON plan* output against rules.
*   **Sentinel:** HashiCorp's embedded policy engine.
*   **Example Rule:** "All S3 buckets must have Versioning enabled and Public Access Blocked. If not, the `terraform apply` fails."

---

## 3. Technical Implementation

### Secure Backend Configuration
A production-grade backend setup for a security team:

```hcl
terraform {
  backend "s3" {
    bucket         = "corp-sec-tfstate-prod"
    key            = "network/vpc.tfstate"
    region         = "us-east-1"
    
    # SECURITY CONTROLS
    encrypt        = true
    kms_key_id     = "alias/tf-state-key"  # Customer Managed Key
    dynamodb_table = "tf-state-lock"       # State Locking
  }
}
```

### Implementing Policy-as-Code (OPA Example)
Instead of manually checking if a Security Group is open to the world, write a test.

**1. Generate the Plan:**
`terraform plan -out=tfplan.binary`
`terraform show -json tfplan.binary > tfplan.json`

**2. The Policy (rego):**
```rego
package terraform.security

# Deny if any security group allows 0.0.0.0/0 on port 22
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_security_group"
    rule := resource.change.after.ingress[_]
    
    rule.from_port == 22
    rule.cidr_blocks[_] == "0.0.0.0/0"
    
    msg = sprintf("CRITICAL: Resource '%s' opens SSH to the world.", [resource.address])
}
```

---

## 4. Operational Lab: Drift Detection

### Scenario
A "Shadow IT" admin manually logged into the AWS Console and opened a firewall port for debugging, bypassing Terraform. This is **Drift**. Your goal is to detect and revert it.

### Directives

#### step 1: Establish Baseline
Deploy a secure security group using Terraform.
```bash
terraform apply -auto-approve
```

#### Step 2: Simulate Attack (Drift)
Manually add an inbound rule (Allow All Traffic) to that Security Group via the Cloud Console/GUI.

#### Step 3: Drift Detection
Run a plan in "refresh-only" or standard mode.
```bash
terraform plan
```
**Observation:** Terraform will report:
`Note: Objects have changed outside of Terraform`
It will show the "+" (addition) of the rogue rule.

#### Step 4: Remediation
Run `terraform apply`.
**Result:** Terraform acts as the "Source of Truth." It will **delete** the rogue rule to bring the infrastructure back in line with the code definition.

---

## 5. Debrief & Analysis

### Critical Thinking
1.  **Why is "State Locking" a security feature?**
    *   *Answer:* It prevents "race conditions" where two engineers apply changes at once, potentially corrupting the mapping of resources and causing outages or partial (insecure) deployments.

2.  **Does `sensitive = true` in Terraform Output variables encrypt the data?**
    *   *Answer:* **NO.** It only prevents the value from being printed in the CLI logs. The value is still stored in PLAIN TEXT in the `.tfstate` JSON file. This is why backend encryption is mandatory.

3.  **How do you handle "Secret Zero" (the credential Terraform uses to run)?**
    *   *Answer:* OpenID Connect (OIDC). Configure GitHub Actions or GitLab CI to assume an IAM Role via OIDC federation. No long-lived access keys are stored in the CI/CD platform.
