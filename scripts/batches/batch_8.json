[
    {
        "id": "b-26",
        "content": "# CI/CD Pipeline Security (DevSecOps)\n\n## 1. Orientation\n\n### What this module covers\nThe CI/CD pipeline is the factory floor of modern software. If you compromise the pipeline, you inject malware into every customer who updates their software (e.g., SolarWinds). This module covers securing the pipeline itself.\n\n### Learning Objectives\n*   Identify the **Top 5 Pipeline Risks** (OWASP CI/CD).\n*   Implement **Signed Commits** and **Branch Protection**.\n*   Understand the risk of **Dependency Confusion**.\n\n---\n\n## 2. Core Content\n\n### The Attack Surface\n1.  **Code Injection:** Attacker pushes malicious code to `main`.\n2.  **Poisoned Dependency:** Attacker uploads a package `internal-utils` to a public repo (npm) with a higher version number.\n3.  **Pipeline Persistance:** Malicious Runner/Agent inside the build environment.\n4.  **Artifact Tampering:** Modifying the compiled binary before signing.\n\n### Defenses\n\n#### 1. Branch Protection\nNever allow direct pushes to `main`. Require Pull Requests (PRs) with:\n*   Minimum 1 reviewer.\n*   Successful CI Status Checks (Tests pass).\n*   Signed Commits (GPG) to verify identity.\n\n#### 2. Dependency Pinning\nDon't use `npm install package@latest`. \n*   **Pin via Hash:** `package@1.2.3` is good. `package@sha256:abc...` is better.\n*   **Lockfiles:** Always commit `package-lock.json`.\n\n#### 3. Artifact Signing (SLSA)\nSupply-chain Levels for Software Artifacts (SLSA).\n*   Generate a **SBOM** (Software Bill of Materials).\n*   Sign the binary using a key stored in a secure HSM.\n\n---\n\n## 3. Lab: The Poisoned Pipeline\n\n### Scenario\nYou are auditing a GitHub Actions workflow.\n\n**Vulnerable Config:**\n```yaml\non: [pull_request_target]\njobs:\n  build:\n    runs-on: self-hosted\n    steps:\n       - run: npm install && npm test\n```\n**The Vulnerability:**\n`pull_request_target` runs in the context of the *target* repo (with secrets), even for forks. A malicious PR can change `npm test` to `cat /etc/passwd` or `env` to print secrets.\n\n**Fix:**\nUse `on: [pull_request]` (runs in isolated context) or strictly sanitize input.\n\n---\n\n## 4. Reflection\n1.  Why is \"SolarWinds\" the textbook example of Pipeline attacks? (Attackers didn't change the source code. They compromised the *build system* to inject code during compilation).\n2.  What is a \"Homer\" attack (Golden SAML)? (Forging authentication tokens to move laterally in the cloud environment connected to the pipeline).\n"
    },
    {
        "id": "b-27",
        "content": "# Container Fundamentals (Docker)\n\n## 1. Orientation\n\n### What this module covers\nContainers are \"Processes on Steroids,\" not \"Mini VMs.\" They share the Host Kernel. This means if you escape a container, you are often Root on the host. This module defines the underlying Linux primitives: **Namespaces** and **Cgroups**.\n\n### Learning Objectives\n*   Explain **Namespaces** (Isolation) vs **Cgroups** (Resource Control).\n*   Deconstruct a `Dockerfile` for security flaws.\n*   Understand the **Docker Daemon** attack surface.\n\n---\n\n## 2. Core Content\n\n### Under the Hood\nDocker is a wrapper around Linux features:\n1.  **Namespaces:** What you can *see*. (PID, Network, Mount, User).\n    *   *PID Namespace:* Process 1 in container looks like Process 1. On host, it's Process 4567.\n2.  **Cgroups (Control Groups):** What you can *use*. (CPU, RAM limits).\n\n### The Dockerfile\nInstructions to build an image.\n\n**Secure Dockerfile Example:**\n```dockerfile\n# 1. Use specific base image (Minimize surface area)\nFROM alpine:3.14 \n\n# 2. Don't run as Root\nRUN addgroup -S appgroup && adduser -S appuser -G appgroup\nUSER appuser\n\n# 3. Copy only what is needed\nCOPY --chown=appuser:appgroup . /app\n```\n\n### The Deadly Flag: `--privileged`\nRunning `docker run --privileged` gives the container access to *all* host devices.\n*   **Impact:** Container can mount the host's hard drive and wipe it. It disables almost all security namespaces.\n\n---\n\n## 3. Lab: Container Escape (Simulation)\n\n### Scenario\nYou have a container running as Root.\n\n1.  **Check Capabilities:** `capsh --print`.\n2.  **Mount Host Disk:** If you are privileged, you can run:\n    ```bash\n    mkdir /host\n    mount /dev/sda1 /host\n    cat /host/etc/shadow\n    ```\n3.  **Result:** You have the Host's password hashes. Game Over.\n\n**Defense:** NEVER run as Root. Use `USER appuser` in Dockerfile. Drop Capabilities (`--cap-drop=ALL`).\n\n---\n\n## 4. Reflection\n1.  Why is `alpine` preferred over `ubuntu` for base images? (Smaller size = fewer installed packages = fewer vulnerabilities).\n2.  Is a container a security boundary? (By default, no. It's an application delivery mechanism. You must add barriers like Seccomp and AppArmor to make it secure).\n"
    },
    {
        "id": "b-28",
        "content": "# Container Security Scanning\n\n## 1. Orientation\n\n### What this module covers\nYour application code might be secure, but what about the OS libraries inside your container? Module b-28 covers **Static Analysis for Containers** (SCA). We will use tools like **Trivy**, **Grype**, and **Clair**.\n\n### Learning Objectives\n*   Scan an image for CVEs.\n*   Understand **Distroless** images.\n*   Implement \"Golden Image\" pipelines.\n\n---\n\n## 2. Core Content\n\n### The Dependency Tree\n`Your App` -> depends on `Node.js` -> depends on `OpenSSL` -> depends on `libc`.\nA vulnerability in `OpenSSL` is a vulnerability in your Container.\n\n### Scanning with Trivy\nTrivy is a comprehensive scanner.\n*   **Command:** `trivy image myapp:latest`\n*   **Output:** List of CVEs (Critical, High, Medium) and \"Fixed Version\".\n\n### The Fix: Distroless\nGoogle's \"Distroless\" images contain *only* your application and its runtime dependencies. They do not contain package managers, shells, or standard linux tools.\n*   *Why?* If an attacker breaks in, they can't run `ls`, `curl`, or `apt-get`.\n*   *Base:* `gcr.io/distroless/nodejs`.\n\n### Golden Images\nDon't pull `node:latest` in every build. \n1.  Security Team pulls `node:lts`, scans it, hardens it.\n2.  Push to private registry as `company/node:18-secure`.\n3.  Devs use `FROM company/node:18-secure`.\n\n---\n\n## 3. Lab: Scanning & Patcing\n\n### Task\n1.  **Pull:** `docker pull python:3.4-alpine` (Very old).\n2.  **Scan:** `trivy image python:3.4-alpine`.\n3.  **Result:** 50+ Vulnerabilities. Some Critical.\n\n**Remediation:**\n1.  Change Dockerfile to `FROM python:3.11-alpine`.\n2.  **Scan:** 0 Vulnerabilities.\n3.  **Lesson:** Simply updating the base image eliminates 90% of container risks.\n\n---\n\n## 4. Reflection\n1.  What is the different between OS Vulnerabilities and App Vulnerabilities? (OS = `libc`, `bash`. App = `pip` packages, `npm` modules. You must scan both).\n2.  Can you patch a running container? (No. Containers are immutable. You patch the *image* and redeploy a new container).\n"
    },
    {
        "id": "b-29",
        "content": "# Kubernetes Architecture & Attack Surface\n\n## 1. Orientation\n\n### What this module covers\nKubernetes (K8s) is the OS of the Cloud. It orchestrates containers. It is notoriously complex and insecure by default. This module explains the **Control Plane**, **Worker Nodes**, and the API Server.\n\n### Learning Objectives\n*   Map the K8s Architecture (Etcd, API Server, Kubelet).\n*   Identify the **Kubelet** as a primary attack vector.\n*   Understand the concept of **Pods** vs Containers.\n\n---\n\n## 2. Core Content\n\n### The Control Plane (The Brain)\n1.  **API Server:** The front door. REST API. Everyone talks to this.\n2.  **Etcd:** The database. Stores all state (and secrets). **Target #1**.\n3.  **Scheduler:** Decides where to put pods.\n4.  **Controller Manager:** Enforces state.\n\n### The Worker Node (The Muscle)\n1.  **Kubelet:** The agent running on the node. Takes orders from API Server.\n2.  **Kube-proxy:** Handles networking.\n3.  **Container Runtime:** (Docker/Containerd).\n\n### The Attack Surface\n*   **Anonymous Access:** Older K8s versions allowed anonymous access to the API server.\n*   **Kubelet API:** Often left open on port 10250. Allows remote code execution if unauthenticated.\n*   **Secrets:** Stored in Etcd. If Etcd is not encrypted at rest, anyone with disk access can read all secrets.\n\n---\n\n## 3. Lab: Talking to the API\n\n### Scenario\nYou land on a compromised pod.\n\n1.  **Check Service Account:**\n    `ls /var/run/secrets/kubernetes.io/serviceaccount/`\n    *   You see `token` and `ca.crt`.\n2.  **Use the Token:**\n    ```bash\n    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\n    curl -k -H \"Authorization: Bearer $TOKEN\" https://kubernetes.default/api/v1/pods\n    ```\n3.  **Result:**\n    *   *Forbidden (403):* Good. RBAC is working.\n    *   *JSON List of Pods:* Bad. The Service Account has too many permissions.\n\n---\n\n## 4. Reflection\n1.  Why is Etcd called the \"Crown Jewels\"? (Because if you write to Etcd, you change the cluster state. You can write \"Make me Admin\" directly into the DB).\n2.  What is a \"Sidecar\"? (A helper container running in the same pod as the main app. Often used for logging or service mesh proxies).\n"
    },
    {
        "id": "b-30",
        "content": "# Kubernetes Security Hardening\n\n## 1. Orientation\n\n### What this module covers\nDefault K8s is open. Hardened K8s is a fortress. This module covers **RBAC** (Role Based Access Control), **Network Policies** (Firewalls for Pods), and **Pod Security Standards (PSS)**.\n\n### Learning Objectives\n*   Write a restrictive **Network Policy**.\n*   Audit **RBAC Roles** for privilege escalation.\n*   Enforce **Pod Security Admission** (Block Root containers).\n\n---\n\n## 2. Core Content\n\n### Network Policies\nBy default, all pods can talk to all pods. (Flat network). \n*   **Attack:** Web Pod hacked -> Connect to Database Pod directly.\n*   **Defense:** NetworkPolicy (YAML) that says \"DB can only accept connections from Web\".\n\n### RBAC (Role Based Access Control)\n*   **Role:** Permissions within a Namespace.\n*   **ClusterRole:** Permissions across the entire cluster.\n*   *Dangerous:* `verbs: [\"*\"]`, `resources: [\"secrets\"]`.\n\n### Pod Security Standards (PSS)\nReplacing the old \"Pod Security Policy (PSP)\".\n*   **Privileged:** Unrestricted.\n*   **Baseline:** Minimal restrictions.\n*   **Restricted:** Heavily hardened (No Root, Drop Capabilities, Seccomp required). \n*   *Enforcement:* Via Admission Controllers.\n\n---\n\n## 3. Lab: The Network Firewall\n\n### Task\nIsolate the `backend` namespace so it only accepts traffic from `frontend`.\n\n**NetworkPolicy.yaml**\n```yaml\nkind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n  name: allow-frontend\n  namespace: backend\nspec:\n  podSelector:\n    matchLabels:\n      app: db\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: frontend\n```\n*   **Effect:** If you exec into a `debug` pod in the `default` namespace and try to curl the DB, it hangs. Connection refused.\n\n---\n\n## 4. Reflection\n1.  Why is \"Namespace\" not a hard security boundary? (It segregates resources, but unless you have Network Policies, traffic can still flow between namespaces).\n2.  What is an \"Admission Controller\"? (A piece of code that intercepts requests to the API server *before* an object is persisted. It's the bouncer that says \"No Root Containers Allowed\").\n"
    }
]