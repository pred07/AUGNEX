[
    {
        "id": "b-10",
        "content": "# Virtualization Fundamentals\n\n## 1. Orientation\n\n### What this module covers\nVirtualization is the creation of a virtual version of something, such as an operating system, a server, a storage device, or network resources. For security professionals, it is the bedrock of safe testing, malware analysis, and scalable infrastructure. This module explores the architecture of virtualization, distinguishing it from containerization, and establishing the importance of isolation.\n\n### Learning Objectives\n*   Differentiate between Physical HW, Host OS, and Guest OS.\n*   Understand the Concept of \"Abstraction Layer.\"\n*   Compare Virtual Machines (VMs) vs. Containers (Docker).\n*   Master the utility of Snapshots for reversible engineering.\n\n---\n\n## 2. Core Content\n\n### Architecture of a VM\nA Virtual Machine (VM) is a software computer that, like a physical computer, runs an operating system and applications. The **Hypervisor** sits between the hardware and the virtual environment.\n\n### VMs vs. Containers\n*   **VMs:** Virtualize the *Hardward*. Each VM has a full OS kernel. heavy, secure isolation.\n*   **Containers:** Virtualize the *Operating System*. Containers share the host kernel. Lightweight, fast, but weaker isolation (Kernel exploits affect all).\n\n### The Security Sandbox\nVirtualization provides a \"Sandbox\"â€”an isolated environment. If you detonate malware in a VM, your Host OS (and personal data) remains safe. \n*   **Warning:** Advanced malware can detect it is in a VM (\"Anti-VM\" techniques) or even escape it (\"VM Escape\" vulnerabilities).\n\n### Snapshots\nThe single most critical feature for experimentation. A snapshot records the state of a VM at a specific point in time.\n*   **Workflow:** Clean State -> Snapshot -> Infect with Malware -> Analyze -> Revert to Clean State.\n\n---\n\n## 3. Lab: Visualizing Isolation\n\n### Task\n1.  Open Task Manager (Windows) or `top` (Linux) on your Host.\n2.  Start a VM (e.g., Kali Linux).\n3.  Run a high-load process in the VM (e.g., `yes > /dev/null`).\n4.  **Observe:** Your Host sees a single process (the Hypervisor) consuming CPU, but cannot see the internal processes of the VM.\n\n---\n\n## 4. Reflection\n1.  Why is a VM better than a Container for analyzing a Windows Virus?\n2.  If you share a folder between Host and Guest, have you broken the sandbox? (Yes. Ransomware can encrypt shared folders).\n"
    },
    {
        "id": "b-11",
        "content": "# Hypervisor Architectures (Type 1 vs Type 2)\n\n## 1. Orientation\n\n### What this module covers\nThe Hypervisor (or Virtual Machine Monitor - VMM) is the software that creates and runs virtual machines. Understanding the two primary types of hypervisors is essential for designing secure architecture, whether for a home lab or an enterprise cloud.\n\n### Learning Objectives\n*   Distinguish between Type 1 (Bare Metal) and Type 2 (Hosted).\n*   Identify common hypervisors in the market (ESXi, Hyper-V, KVM, VirtualBox).\n*   Understand the performance and security implications of each.\n\n---\n\n## 2. Core Content\n\n### Type 1: Bare Metal\nInstalled directly on the physical server hardware. There is no underlying OS.\n*   **Examples:** VMware ESXi, Microsoft Hyper-V (Core), Xen.\n*   **Use Case:** Enterprise Data Centers, Cloud Providers (AWS EC2).\n*   **Performance:** High (Direct hardware access).\n*   **Security:** High (Smaller attack surface, no Host OS vulnerabilities).\n\n### Type 2: Hosted\nInstalled as an application on top of an existing Operating System.\n*   **Examples:** Oracle VirtualBox, VMware Workstation, Parallels.\n*   **Use Case:** Personal desktops, Developer testing, Security researcher labs.\n*   **Performance:** Lower (Overhead of Host OS + Hypervisor Application).\n*   **Security:** Lower (If Host OS is compromised, all VMs are compromised).\n\n### KVM (Kernel-based Virtual Machine)\nLinux's unique approach. KVM turns the Linux kernel into a Type 1 hypervisor, but allows it to function as a general OS. It powers most of the cloud (AWS, Google Cloud).\n\n---\n\n## 3. Lab: Hypervisor Recon\n\n### Scenario\nYou are auditing a server.\n1.  **Check for Virtualization:** \n    *   Linux: `lscpu | grep Virtualization`\n    *   Windows: `systeminfo`\n2.  **Identify the Platform:**\n    *   Look for MAC Address OUIs (00:0C:29 is VMware).\n    *   Check for Drivers (VirtIO).\n\n---\n\n## 4. Reflection\n1.  Why involves less latency: A Type 1 hypervisor or Type 2? Why?\n2.  Can you run a Type 2 hypervisor inside a Type 1 hypervisor? (Yes, this is called \"Nested Virtualization\").\n"
    },
    {
        "id": "b-12",
        "content": "# Bash Scripting for Security Automation\n\n## 1. Orientation\n\n### What this module covers\nThe `Bash` shell is the command interface for Linux. Scripting in Bash allows you to automate tedious tasks, chain tools together, and process large text files. For a hacker/engineer, Bash fluency is non-negotiable.\n\n### Learning Objectives\n*   Automate repetitive terminal commands.\n*   Master `stdin`, `stdout`, and `stderr` (Redirection).\n*   Use pipes `|` to chain tools.\n*   Perform text processing with `grep`, `awk`, and `cut`.\n\n---\n\n## 2. Core Content\n\n### The Shebang\nEvery script starts with `#!/bin/bash`. This tells the system which interpreter to use.\n\n### Variables & Loops\n```bash\n#!/bin/bash\nIP_PREFIX=\"192.168.1\"\nfor i in {1..254}; do\n    ping -c 1 $IP_PREFIX.$i > /dev/null\n    if [ $? -eq 0 ]; then\n        echo \"Host $IP_PREFIX.$i is UP\"\n    fi\ndone\n```\n*   `$?` holds the exit status of the last command (0 = Success).\n\n### The Power of Pipes (`|`)\nPipes pass the output of one command as input to the next.\n*   *Example:* Find all active web connections.\n    `netstat -antp | grep ESTABLISHED | grep :80`\n\n### Text Processing Trinity\n1.  **Grep:** Search. `grep \"Error\" /var/log/syslog`\n2.  **Cut:** Slice columns. `cut -d \":\" -f 1 /etc/passwd` (Get usernames).\n3.  **Awk:** Advanced formatting. `ps aux | awk '{print $1, $11}'` (Print User and Process).\n\n---\n\n## 3. Lab: The Log Parser\n\n### Task\nYou have an apache access log. Find the Top 5 IP addresses attempting to access `admin.php`.\n\n**Command:**\n```bash\ncat access.log | grep \"admin.php\" | awk '{print $1}' | sort | uniq -c | sort -nr | head -n 5\n```\n**Breakdown:** Filter for page -> Extract IP -> Sort for grouping -> Count unique -> Sort numerically reverse -> Top 5.\n\n---\n\n## 4. Reflection\n1.  Why use `bash` instead of `python`? (For quick system interactions and piping existing binary tools, Bash is faster to write).\n2.  What does `2>&1` mean? (Redirect Stderr to Stdout).\n"
    },
    {
        "id": "b-13",
        "content": "# Python for Security: Basics & Requests\n\n## 1. Orientation\n\n### What this module covers\nPython is the industry standard for security tool development due to its readability and massive library ecosystem. While Bash is for gluing tools, Python is for *building* tools. This module focuses on setting up a dev environment and interacting with the Web.\n\n### Learning Objectives\n*   Set up a Python Virtual Environment (`venv`).\n*   Understand Python syntax for security (Strings, Lists, Dicts).\n*   Use the `requests` library to interact with HTTP services.\n\n---\n\n## 2. Core Content\n\n### The Environment\nAlways isolate dependencies.\n```bash\npython3 -m venv myenv\nsource myenv/bin/activate\npip install requests\n```\n\n### Data Structures for Hackers\n*   **Lists:** Organizing targets. `ips = [\"10.0.0.1\", \"10.0.0.2\"]`\n*   **Dictionaries:** Storing credentials/configs. `creds = {\"user\": \"admin\", \"pass\": \"12345\"}`\n\n### The `requests` Library\nThe Swiss Army knife for Web Hacking (Fuzzing, Brute-forcing, API testing).\n\n```python\nimport requests\n\nurl = \"http://target.com/login\"\ndata = {\"username\": \"admin\", \"password\": \"password123\"}\n\nresponse = requests.post(url, data=data)\n\nif \"Welcome\" in response.text:\n    print(f\"[+] Success: {data['password']}\")\nelse:\n    print(f\"[-] Failed: {response.status_code}\")\n```\n\n---\n\n## 3. Lab: Directory Fuzzer\n\n### Task\nWrite a script that takes a URL and a wordlist, checking for existing pages.\n\n```python\nimport requests\nimport sys\n\ntarget = sys.argv[1]\nwordlist = open(\"common.txt\", \"r\")\n\nfor line in wordlist:\n    directory = line.strip()\n    full_url = f\"{target}/{directory}\"\n    r = requests.get(full_url)\n    if r.status_code != 404:\n        print(f\"[+] Found: {full_url} ({r.status_code})\")\n```\n\n---\n\n## 4. Reflection\n1.  Why use `sys.argv`? (To accept command line arguments).\n2.  What is the difference between `requests.get()` and `requests.post()`? (GET retrieves method, POST submits data).\n"
    },
    {
        "id": "b-14",
        "content": "# Python for Security: Sockets & Automation\n\n## 1. Orientation\n\n### What this module covers\nGoing lower level. While `requests` handles HTTP, `socket` handles raw networking (TCP/UDP). This is essential for understanding how port scanners, reverse shells, and exploit payloads work across the wire.\n\n### Learning Objectives\n*   Understand the Client-Server model.\n*   Create a creating TCP connection using `socket`.\n*   Implement Exception Handling for robust tools.\n*   Build a simple Port Scanner.\n\n---\n\n## 2. Core Content\n\n### The Socket Object\nA socket is an endpoint for sending or receiving data.\n\n```python\nimport socket\n\n# Create socket (IPv4, TCP)\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to target\ns.connect((\"192.168.1.5\", 22))\n\n# Receive Banner\nbanner = s.recv(1024)\nprint(banner.decode())\n\n# Close\ns.close()\n```\n\n### Exception Handling\nNetworks are messy. Hosts go down. Packets drop. Scripts must not crash.\n\n```python\ntry:\n    s.connect((ip, port))\nexcept ConnectionRefusedError:\n    print(\"Port is closed.\")\nexcept socket.timeout:\n    print(\"Host timed out.\")\n```\n\n### Automation logic\nCombine Loops + Sockets = Scanner.\n\n---\n\n## 3. Lab: The Port Scanner\n\n### Task\nBuild a threaded port scanner is complex, but start with a linear one.\n\n```python\nimport socket\n\ntarget = \"192.168.1.10\"\nports = [21, 22, 80, 443, 3389]\n\nprint(f\"Scanning {target}...\")\n\nfor port in ports:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.settimeout(1)\n    result = s.connect_ex((target, port)) # Returns 0 if success\n    if result == 0:\n        print(f\"Port {port}: OPEN\")\n    s.close()\n```\n\n---\n\n## 4. Reflection\n1.  Why do we need `.decode()` on receive? (Sockets transmit bytes; we need strings).\n2.  What is `AF_INET`? (Address Family for IPv4).\n"
    },
    {
        "id": "b-15",
        "content": "# Secure Coding Principles\n\n## 1. Orientation\n\n### What this module covers\nSecurity is not just about breaking; it's about building. \"Shift Left\" means addressing security early in the SDLC. This module covers the universal principles of writing secure code, regardless of the language.\n\n### Learning Objectives\n*   Understand the CIA Triad in code.\n*   Master Input Validation (Sanitization).\n*   Master Output Encoding.\n*   Apply the Principle of Least Privilege.\n\n---\n\n## 2. Core Content\n\n### The Root of All Evil: Untrusted Input\nMost web vulnerabilities (SQLi, XSS, Command Injection) stem from the same mistake: **Trusting user input.**\n\n**Vulnerable Code (Python):**\n```python\nimport os\nuser_input = input(\"Enter IP to ping: \")\nos.system(\"ping \" + user_input)\n```\n*   *Exploit:* Input `127.0.0.1; rm -rf /`\n\n### Defensive Strategy 1: Input Validation\nAssert that input matches expectations *before* processing.\n*   **Allow-listing (Good):** \"Only allow a-z, 0-9\".\n*   **Block-listing (Bad):** \"Block the word 'script'\". (Attackers will bypass with 'ScRipt').\n\n**Secure Code:**\n```python\nimport re\nif not re.match(r\"^[0-9\\.]+\", user_input):\n    raise ValueError(\"Invalid IP format\")\n```\n\n### Defensive Strategy 2: Parameterization\nNever treat data as executable code. \n*   **SQL Injection:** Use Prepared Statements (`?` or `%s` placeholders) instead of string concatenation.\n\n### Defensive Strategy 3: Output Encoding\nWhen displaying data back to a user, convert special characters to HTML entities.\n*   `<script>` becomes `&lt;script&gt;`.\n*   This neutralizes Cross-Site Scripting (XSS).\n\n---\n\n## 3. Lab: Code Review\n\n### Task\nIdentify the flaw in this PHP snippet:\n```php\n$id = $_GET['id'];\n$query = \"SELECT * FROM users WHERE id = \" . $id;\n```\n*   **Flaw:** String concatenation allows SQL Injection.\n*   **Fix:** Use `PDO` with prepared statements `prepare('SELECT * FROM users WHERE id = :id')`.\n\n---\n\n## 4. Reflection\n1.  Why is Client-Side validation (JS) insufficient? (Attackers can bypass the browser and send requests directly via Burp Suite).\n2.  Whose responsibility is secure code? (Every developer, not just the security team).\n"
    }
]