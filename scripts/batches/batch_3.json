[
    {
        "id": "s-14",
        "content": "# Indicators of Compromise (IOCs) & The Pyramid of Pain\n\n## 1. Orientation\n\n### What this module covers\nIn Cyber Threat Intelligence (CTI), not all data is created equal. An IP Address is easy to change; a TTP (Tactic, Technique, Procedure) is hard to change. This module defines the hierarchy of threat indicators using David Bianco's **Pyramid of Pain**.\n\n### Learning Objectives\n*   Categorize indicators into the 6 levels of the Pyramid of Pain.\n*   Understand why \"TTPs\" are the gold standard of detection.\n*   Differentiate between \"Atomic\", \"Computed\", and \"Behavioral\" indicators.\n\n---\n\n## 2. Core Content\n\n### The Pyramid of Pain\n\n| Level | Indicator | Value to Defender | Pain to Attacker |\n| :--- | :--- | :--- | :--- |\n| **Top** | **TTPs** | High | **Tough** (Must relearn tradecraft) |\n| 5 | **Tools** | High | Challenging (Must rewrite software) |\n| 4 | **Network Artifacts** | Medium | Annoying (Change User-Agent/C2) |\n| 3 | **Domain Names** | Low | Simple (Register new domain) |\n| 2 | **IP Addresses** | Low | Easy (Change VPN/Proxy) |\n| **Base** | **Hash Values** | Low | **Trivial** (Change 1 bit of file) |\n\n### Indicator Types\n1.  **Atomic:** Small, simple pieces of data (IP, Email, Domain). High volume, short lifespan.\n2.  **Computed:** Derived from data (Hashes: MD5, SHA256). Unique to specific files.\n3.  **Behavioral:** Logic or actions (Macro executes PowerShell, Process A spawns Process B).\n\n### The Ephemeral Nature of IOCs\nAn IP address used by APT29 today might be used by a grandmother in Ohio tomorrow. **Context is King.** Blocking IPs without context leads to false positives. \n\n---\n\n## 3. Lab: Climbing the Pyramid\n\n### Scenario\nYou have a report on \"Emotet\". Classify the following extract:\n\n> \"The malware arrives via email (phishing) containing a Word Doc. The Doc uses a Macro to spawn PowerShell. It connects to `192.168.55.10` to download `payload.exe` (Hash: `a1b2c3...`).\"\n\n**Classification:**\n1.  **TTP:** Phishing (Initial Access), Macro spawns PowerShell (Execution).\n2.  **Network Artifact:** Connection to `192.168.55.10`.\n3.  **Hash:** `a1b2c3...`.\n\n**Defender Strategy:**\n*   Blocking the Hash? Helps for 5 minutes.\n*   Blocking the IP? Helps for 1 day.\n*   Blocking \"Word spawning PowerShell\"? **Stops the attack permanently** (until they change tactics).\n\n---\n\n## 4. Reflection\n1.  Why do we still share Hashes if they are \"trivial\" to change? (Because they are cheap, easy, and give quick wins against lazy attackers).\n2.  Why is detecting TTPs harder? (It requires understanding *intent* and *process*, not just matching a string).\n"
    },
    {
        "id": "s-15",
        "content": "# YARA: The Pattern Matching Standard\n\n## 1. Orientation\n\n### What this module covers\nYARA (Yet Another Recursive Acronym) is the industry standard for identifying malware by pattern matching. It works on **files**. If you want to find a specific malware sample based on string or binary patterns, you write a YARA rule.\n\n### Learning Objectives\n*   Write a basic YARA rule structure (Meta, Strings, Condition).\n*   Use Hexadecimal strings for binary matching.\n*   Use the `any of them` and `filesize` conditions.\n\n---\n\n## 2. Core Content\n\n### Rule Structure\nA YARA rule has three sections:\n\n```yara\nrule Example_Malware {\n    meta:\n        author = \"CyberDef\"\n        description = \"Detects generic malware\"\n    strings:\n        $text_string = \"EvilCorp v1.0\"\n        $hex_string = { E2 34 A1 C8 23 FB }\n    condition:\n        $text_string or $hex_string\n}\n```\n\n### String Types\n1.  **ASCII:** `$a = \"string\"`. Case sensitive.\n2.  **Nocase:** `$a = \"string\" nocase`. Case insensitive.\n3.  **Wide:** `$a = \"string\" wide`. Matches UTF-16 (Windows default).\n4.  **Hex:** `$a = { 4D 5A }`. Matches binary bytes (e.g., MZ header).\n\n### Conditions\nThe logic gate.\n*   `any of them`: Matches if any string is found.\n*   `$a and $b`: Both must be present.\n*   `filesize < 500KB`: Optimize performance (skip huge files).\n*   `uint16(0) == 0x5A4D`: Check if file starts with \"MZ\" (Process Executable).\n\n---\n\n## 3. Lab: Writing a Rule\n\n### Task\nWrite a YARA rule to detect a webshell that always contains the variable `$_POST['cmd']` and is smaller than 20KB.\n\n**Solution:**\n```yara\nrule PHP_Webshell_CMD {\n    meta:\n        description = \"Detects PHP command execution webshell\"\n    strings:\n        $s1 = \"$_POST\" nocase\n        $s2 = \"['cmd']\" nocase\n    condition:\n        all of them and filesize < 20KB\n}\n```\n\n---\n\n## 4. Reflection\n1.  Why use `wide` strings for Windows malware? (Windows stores strings as Unicode; ASCII searches will miss them).\n2.  What happens if your rule is too generic (e.g., matching the string \"Microsoft\")? (False Positives. You will flag legitimate system files).\n"
    },
    {
        "id": "s-16",
        "content": "# SIGMA: Generic Log Signatures\n\n## 1. Orientation\n\n### What this module covers\nWhile YARA matches *files*, SIGMA matches *logs*. SIGMA is the open standard for SIEM rules. You write a rule in SIGMA, and it can be converted to Splunk (SPL), Elastic (KQL), or Microsoft Sentinel queries.\n\n### Learning Objectives\n*   Understand the YAML structure of a SIGMA rule.\n*   Map Sigma fields to Windows Event Logs.\n*   Convert a Sigma rule to a Splunk query.\n\n---\n\n## 2. Core Content\n\n### The Problem\nYou have a generic detection: \"Detect PowerShell downloading a file.\" \n*   Your Splunk Syntax: `index=winlog EventCode=4104 ...`\n*   Your Client's Elastic Syntax: `event.code: 4104 AND process.name: powershell ...`\n*   **Solution:** Write *one* SIGMA rule, convert to both.\n\n### Rule Structure (YAML)\n```yaml\ntitle: Suspicious PowerShell Download\nid: 1234-5678\nstatus: experimental\ndescription: Detects usage of Net.WebClient in PowerShell\nlogsource:\n    product: windows\n    service: powershell\ndetection:\n    selection:\n        EventID: 4104\n        ScriptBlockText|contains:\n            - 'System.Net.WebClient'\n            - 'DownloadFile'\n    condition: selection\nlevel: medium\n```\n\n### Key Parsers\n*   `selection`: The logic to match (AND logic by default within a list).\n*   `condition`: specific logic (e.g., `selection1 and not selection2`).\n\n---\n\n## 3. Lab: Breaking the Query\n\n### Task\nTranslate this English requirement into SIGMA logic:\n\"Detect any process clearing the Security Event Log (Event ID 1102).\"\n\n**Sigma Draft:**\n```yaml\nlogsource:\n    product: windows\n    service: security\ndetection:\n    selection:\n        EventID: 1102\n    condition: selection\n```\n\n**Splunk Output:** `index=wineventlog EventCode=1102`\n\n---\n\n## 4. Reflection\n1.  Why is SIGMA called the \"YARA of Logs\"? (It standardizes detection logic independent of the backend tool).\n2.  Where can you find pre-written Sigma rules? (The SigmaHQ GitHub repository is the main source).\n"
    },
    {
        "id": "s-17",
        "content": "# Malware Analysis: Static Properties\n\n## 1. Orientation\n\n### What this module covers\nMalware Analysis is the art of dissecting malicious software to understand *what* it does and *how* to stop it. We start with **Basic Static Analysis**—examining the file without running it. It is safe, fast, but limited by obfuscation.\n\n### Learning Objectives\n*   Calculate and search file **Hashes**.\n*   Extract **Strings** to find IP addresses or text.\n*   Inspect the **PE Header** (Import Address Table).\n*   Use **Packer Detection** (PEiD/Die).\n\n---\n\n## 2. Core Content\n\n### Hashing & VirusTotal\nThe first step: Fingerprint the file.\n*   `sha256sum malware.exe`\n*   Search the hash on VirusTotal. If 50/60 vendors detect it, you save time.\n\n### Strings\nRunning `strings malware.exe` extracts printable characters. \n*   *Look for:* IPs (`1.2.3.4`), URLs (`http://evil.com`), filenames (`ransom_note.txt`), API calls (`CreateProcess`).\n*   *Limitation:* Packed malware looks like garbage code.\n\n### The PE Header (Windows Executables)\nThe Portable Executable (PE) header tells the OS how to load the program. The **Import Address Table (IAT)** lists the DLLs and functions the malware imports.\n*   *Suspicious Imports:* `InternetOpen` (Network), `CryptEncrypt` (Ransomware?), `SetWindowsHookEx` (Keylogger?).\n\n### Packing\nMalware authors \"Pack\" (compress/encrypt) their verify code to hide strings.\n*   **Signs of Packing:** High Entropy (randomness), very few Imports (`GetProcAddress`, `LoadLibrary`), section names like UPX.\n\n---\n\n## 3. Lab: The Skeptic's View\n\n### Scenario\nYou have a file `invoice.exe`.\n1.  **Hash:** Unknown in VirusTotal.\n2.  **Strings:** You see nothing readable except \"UPX0\" and \"UPX1\".\n3.  **Imports:** Only `LoadLibrary` and `GetProcAddress`.\n\n**Conclusion:** The file is **Packed**. Static analysis is hitting a wall. You must unpack it or use Dynamic Analysis.\n\n---\n\n## 4. Reflection\n1.  Why is entropy a sign of packing? (Encrypted data looks statistically random/high noise, whereas code has patterns).\n2.  Can static analysis detonate the malware? (No. You are reading the file, not executing CPU instructions).\n"
    },
    {
        "id": "s-18",
        "content": "# Malware Analysis: Dynamic Behavior\n\n## 1. Orientation\n\n### What this module covers\nWhen Static Analysis fails (due to packing/obfuscation), we move to **Basic Dynamic Analysis**. We run the malware in a controlled, isolated environment and observe its behavior.\n\n### Learning Objectives\n*   Set up a safe **Sandbox** (Host-Only Network).\n*   Monitor **Process Activity** (ProcMon).\n*   Monitor **Network Traffic** (Wireshark/Fiddler).\n*   Monitor **DNS Queries** (FakeNet).\n\n---\n\n## 2. Core Content\n\n### The Golden Rule of Dynamic Analysis\n**NEVER** run malware on your host or a machine with internet access (unless specifically engineered to do so via a Dirty Line). Use a VM with snapshots.\n\n### The Toolset\n1.  **Sysinternals Process Monitor (ProcMon):** Records file system, registry, and process activity. \"Did it write to `C:\\Windows\\System32`?\"\n2.  **Process Explorer:** Visually view parent-child process relationships. \"Why did `calc.exe` spawn `powershell.exe`?\"\n3.  **Wireshark:** Capture packets. \"Is it beaconing to a C2 server?\"\n4.  **RegShot:** Compare Registry before and after execution (Snapshot A vs Snapshot B).\n\n### Indicators of Compromise (IOCs)\nDynamic analysis generates the IOCs we discussed in Module s-14: \n*   New Files created.\n*   Registry Keys for Persistence (`Run` keys).\n*   C2 Domains/IPs contacted.\n\n---\n\n## 3. Lab: Bursting the Bubble\n\n### Scenario\nYou run `malware.exe` in your lab.\n\n1.  **ProcMon:** Shows writes to `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Updater`. (Persistence established).\n2.  **Wireshark:** Shows a DNS query for `update-checker-secure.com` followed by HTTP POST requests.\n3.  **Process Explorer:** Shows `malware.exe` spawned `cmd.exe`.\n\n**Analysis:** The malware installs persistence, attempts C2 communication, and opens a command shell.\n\n---\n\n## 4. Reflection\n1.  What is \"Anti-VM\"? (Malware checks if it's in a VM—e.g., checking MAC address or drivers—and quits if detected to fool analysts).\n2.  Why use a \"Host-Only\" network adapter? (To prevent the malware from reaching the real internet while still allowing you to route traffic to a fake internet simulator like INetSim).\n"
    },
    {
        "id": "s-19",
        "content": "# Automated Sandboxing (Cuckoo/CAPE)\n\n## 1. Orientation\n\n### What this module covers\nManual analysis is slow. In an enterprise with 1,000 alerts a day, you need automation. **Automated Malware Sandboxes** (like Cuckoo, CAPE, or commercial FireEye/Palo Alto Wildfire) automatically detonate files and produce a report.\n\n### Learning Objectives\n*   Understand the architecture of an Automated Sandbox.\n*   Interpret a Sandbox Report (Score, Screenshots, Network).\n*   Recognize the limitations of Automation.\n\n---\n\n## 2. Core Content\n\n### How it Works\n1.  **Submission:** Analyst uploads `bad.pdf` via Web UI or API.\n2.  **Orchestration:** The Sandbox spins up a clean VM (Windows 10).\n3.  **Detonation:** It injects the file, opens it, and simulates user activity (moving mouse).\n4.  **Hooking:** The Sandbox injects probes into the kernel/API to record all calls.\n5.  **Reporting:** It kills the VM and generates a JSON/HTML report.\n\n### Interpreting the Score\nMost sandboxes give a \"Maliciousness Score\" (0-10 or 0-100).\n*   **High Risk:** Network traffic to known bad IPs, modifying system files, injecting code.\n*   **False Positives:** Installers, strange but legitimate software.\n\n### CAPE Sandbox (Config And Payload Extraction)\nA fork of Cuckoo designed to extract the payload from packed malware. It can automatically dump the memory of a process once it unpacks itself.\n\n---\n\n## 3. Lab: Reading the Report\n\n### Task\nYou receive a Cuckoo Report.\n*   **Screenshots:** Show a ransom note background.\n*   **Network:** requests to `api.ipify.org` (Check IP) and `c2.attacker.com`.\n*   **Dropped Files:** `crypt.exe` in `%TEMP%`.\n*   **Signatures Triggered:** \"Ransomware behavior detected\", \"Shadow Copies deleted\".\n\n**Verdict:** Ransomware. Isolate affected machines immediately.\n\n---\n\n## 4. Reflection\n1.  Can a Sandbox replace a Human Analyst? (No. Determining *impact* and *intent* often requires human context. Also, Sandboxes can be evaded).\n2.  What is \"Sleep evasion\"? (Malware waits 20 minutes before acting. Sandboxes usually only run for 2-5 minutes, so they miss the behavior).\n"
    },
    {
        "id": "s-20",
        "content": "# Threat Hunting: Hypothesis-Driven Analysis\n\n## 1. Orientation\n\n### What this module covers\nThreat Hunting is **proactive**. Instead of waiting for an alert (Reactive), you assume you are already breached and look for evidence. This requires the **Scientific Method**: Observation -> Hypothesis -> Test -> Conclusion.\n\n### Learning Objectives\n*   Differentiate between Alerting (SOC) and Hunting.\n*   Formulate a testable Hypothesis.\n*   Execute a Hunt using SIEM/EDR data.\n\n---\n\n## 2. Core Content\n\n### The Hunting Loop\n1.  **Hypothesis:** \"I bet attackers are using PowerShell to download malware.\"\n2.  **Investigate:** Generic query for `powershell.exe` making network connections.\n3.  **Uncover patterns:** Filter out admin scripts. Find the anomaly.\n4.  **Enrich:** Check hashes, IPs.\n5.  **Automate:** If you find something, turn that search into a Detection Rule (SIGMA) so you don't have to hunt for it again.\n\n### Hypothesis Generation\nGood hypotheses come from verified Intelligence methods:\n*   **Intelligence Driven:** \"New Intel says APT29 uses `rundll32` for execution. Do we see that?\"\n*   **Situational Awareness:** \"We just merged with Company X. Their network is likely dirty.\"\n*   **Domain Expertise:** \"Our payment portal is our crown jewel. How would I hack it?\"\n\n### Data Sources\n*   **Endpoint:** Process creation, Command line arguments.\n*   **Network:** DNS queries, Long connections (beacons).\n*   **Auth:** Failed logins, lateral movement patterns (4624 type 3).\n\n---\n\n## 3. Lab: The PowerShell Hunt\n\n### Scenario\nHypothesis: \"Attackers are using encoded PowerShell commands to hide.\"\n\n**Query:**\nSearch specific logs for ` -enc ` or ` -encodedcommand `.\n\n**Refinement:**\nMany admins use base64 encoding legitimately. \n*   *New Filter:* Length > 1000 characters.\n*   *New Filter:* Exclude known Service Accounts.\n\n**Findings:**\nYou find a user account `bob` running a 5000-character encoded string at 3 AM. **Confirmed Incident.**\n\n---\n\n## 4. Reflection\n1.  Why is \"Show me all bad things\" a bad hypothesis? (It's not specific. You need to look for *specific behaviors*).\n2.  If a Hunt finds nothing, is it a failure? (No. It proves that *specific* attack vector is likely not present, increasing confidence in security).\n"
    }
]